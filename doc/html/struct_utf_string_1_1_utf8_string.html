<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>UtfString: UtfString::Utf8String Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">UtfString
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_utf_string.html">UtfString</a></li><li class="navelem"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="struct_utf_string_1_1_utf8_string-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">UtfString::Utf8String Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains and manages a UTF-8 string.  
 <a href="struct_utf_string_1_1_utf8_string.html#details">More...</a></p>

<p><code>#include &lt;Utf8String.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_utf8_string_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that iterates through the code points in a UTF-8 string, but allowing only access to constant code points.  <a href="class_utf_string_1_1_utf8_string_1_1const__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_utf8_string_1_1const__reverse__iterator.html">const_reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that iterates through the code points in a UTF-8 string in reverse order, but allowing only access to constant code points.  <a href="class_utf_string_1_1_utf8_string_1_1const__reverse__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that iterates through the code points in a UTF-8 string.  <a href="class_utf_string_1_1_utf8_string_1_1iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_utf8_string_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that iterates through the code points in a UTF-8 string in reverse order.  <a href="class_utf_string_1_1_utf8_string_1_1reverse__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aab048a0e4e1e146b74c0d587fc57fb19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab048a0e4e1e146b74c0d587fc57fb19"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#aab048a0e4e1e146b74c0d587fc57fb19">Utf8String</a> ()</td></tr>
<tr class="memdesc:aab048a0e4e1e146b74c0d587fc57fb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor. <br/></td></tr>
<tr class="separator:aab048a0e4e1e146b74c0d587fc57fb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7e62a25100d41ef82ed615d3d7a1de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#aec7e62a25100d41ef82ed615d3d7a1de">Utf8String</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String)</td></tr>
<tr class="memdesc:aec7e62a25100d41ef82ed615d3d7a1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a string with the contents of another string as its initial value.  <a href="#aec7e62a25100d41ef82ed615d3d7a1de">More...</a><br/></td></tr>
<tr class="separator:aec7e62a25100d41ef82ed615d3d7a1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c2a7f2e2f335cf2eaf3b8e7a56037d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a31c2a7f2e2f335cf2eaf3b8e7a56037d">Utf8String</a> (const std::string utf8String)</td></tr>
<tr class="memdesc:a31c2a7f2e2f335cf2eaf3b8e7a56037d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a string with the contents of another string as its initial value.  <a href="#a31c2a7f2e2f335cf2eaf3b8e7a56037d">More...</a><br/></td></tr>
<tr class="separator:a31c2a7f2e2f335cf2eaf3b8e7a56037d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab78a7f36c47473629e3e708d183015"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a4ab78a7f36c47473629e3e708d183015">Utf8String</a> (const char *utf8String)</td></tr>
<tr class="memdesc:a4ab78a7f36c47473629e3e708d183015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a string with the contents of another string as its initial value.  <a href="#a4ab78a7f36c47473629e3e708d183015">More...</a><br/></td></tr>
<tr class="separator:a4ab78a7f36c47473629e3e708d183015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90920076979c72ab178b1c0d8094f23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ad90920076979c72ab178b1c0d8094f23">Utf8String</a> (const char *utf8String, size_t characterCount)</td></tr>
<tr class="memdesc:ad90920076979c72ab178b1c0d8094f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a string with the contents of another string as its initial value.  <a href="#ad90920076979c72ab178b1c0d8094f23">More...</a><br/></td></tr>
<tr class="separator:ad90920076979c72ab178b1c0d8094f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56014d2b38533d695623cc16192a0335"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a56014d2b38533d695623cc16192a0335">Utf8String</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String)</td></tr>
<tr class="memdesc:a56014d2b38533d695623cc16192a0335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a string with the contents of another string as its initial value.  <a href="#a56014d2b38533d695623cc16192a0335">More...</a><br/></td></tr>
<tr class="separator:a56014d2b38533d695623cc16192a0335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c7a580e1bd5f81aabe9ee1cd4fb257"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ac2c7a580e1bd5f81aabe9ee1cd4fb257">Utf8String</a> (const wchar_t *wideString)</td></tr>
<tr class="memdesc:ac2c7a580e1bd5f81aabe9ee1cd4fb257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a string with the contents of another string as its initial value.  <a href="#ac2c7a580e1bd5f81aabe9ee1cd4fb257">More...</a><br/></td></tr>
<tr class="separator:ac2c7a580e1bd5f81aabe9ee1cd4fb257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7059b736d724926a3b9acb7cca1a10e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a7059b736d724926a3b9acb7cca1a10e7">Utf8String</a> (const wchar_t *wideString, const size_t characterCount)</td></tr>
<tr class="memdesc:a7059b736d724926a3b9acb7cca1a10e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a string with the contents of another string as its initial value.  <a href="#a7059b736d724926a3b9acb7cca1a10e7">More...</a><br/></td></tr>
<tr class="separator:a7059b736d724926a3b9acb7cca1a10e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7506f235cb4aad1c434173a96c4a6b44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a7506f235cb4aad1c434173a96c4a6b44">Utf8String</a> (const std::wstring &amp;wideString)</td></tr>
<tr class="memdesc:a7506f235cb4aad1c434173a96c4a6b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a string with the contents of another string as its initial value.  <a href="#a7506f235cb4aad1c434173a96c4a6b44">More...</a><br/></td></tr>
<tr class="separator:a7506f235cb4aad1c434173a96c4a6b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c0bbe52130faabcb5dc3d3150b0590"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89c0bbe52130faabcb5dc3d3150b0590"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a89c0bbe52130faabcb5dc3d3150b0590">~Utf8String</a> ()</td></tr>
<tr class="memdesc:a89c0bbe52130faabcb5dc3d3150b0590"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class destructor. <br/></td></tr>
<tr class="separator:a89c0bbe52130faabcb5dc3d3150b0590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41eba4db2d896a6bebd34d8ae5b0bd3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a41eba4db2d896a6bebd34d8ae5b0bd3f">append</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String)</td></tr>
<tr class="memdesc:a41eba4db2d896a6bebd34d8ae5b0bd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the contents of another string to this string.  <a href="#a41eba4db2d896a6bebd34d8ae5b0bd3f">More...</a><br/></td></tr>
<tr class="separator:a41eba4db2d896a6bebd34d8ae5b0bd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a94f7f94c6b459c0732d90d6f431896"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a4a94f7f94c6b459c0732d90d6f431896">append</a> (const std::string &amp;utf8String)</td></tr>
<tr class="memdesc:a4a94f7f94c6b459c0732d90d6f431896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the contents of another string to this string.  <a href="#a4a94f7f94c6b459c0732d90d6f431896">More...</a><br/></td></tr>
<tr class="separator:a4a94f7f94c6b459c0732d90d6f431896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c09e5973e16febd3ef785c0491682b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a6c09e5973e16febd3ef785c0491682b8">append</a> (const char *utf8String)</td></tr>
<tr class="memdesc:a6c09e5973e16febd3ef785c0491682b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the contents of another string to this string.  <a href="#a6c09e5973e16febd3ef785c0491682b8">More...</a><br/></td></tr>
<tr class="separator:a6c09e5973e16febd3ef785c0491682b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94723b64663189f12bbac3cdfb77e9c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a94723b64663189f12bbac3cdfb77e9c6">append</a> (const char *utf8String, const size_t codeUnitCount)</td></tr>
<tr class="memdesc:a94723b64663189f12bbac3cdfb77e9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the contents of another string to this string.  <a href="#a94723b64663189f12bbac3cdfb77e9c6">More...</a><br/></td></tr>
<tr class="separator:a94723b64663189f12bbac3cdfb77e9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c09bf8fa83942b97b573245a102482"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a16c09bf8fa83942b97b573245a102482">append</a> (const wchar_t *wideString)</td></tr>
<tr class="memdesc:a16c09bf8fa83942b97b573245a102482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the contents of another string to this string.  <a href="#a16c09bf8fa83942b97b573245a102482">More...</a><br/></td></tr>
<tr class="separator:a16c09bf8fa83942b97b573245a102482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51f39ce19a23afddf8fa03ac1549b1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#aa51f39ce19a23afddf8fa03ac1549b1d">append</a> (const wchar_t *wideString, const size_t characterCount)</td></tr>
<tr class="memdesc:aa51f39ce19a23afddf8fa03ac1549b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the contents of another string to this string.  <a href="#aa51f39ce19a23afddf8fa03ac1549b1d">More...</a><br/></td></tr>
<tr class="separator:aa51f39ce19a23afddf8fa03ac1549b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee0c819cf8db4e63d7c8090d9fc0946"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#aeee0c819cf8db4e63d7c8090d9fc0946">append</a> (const std::wstring &amp;wideString)</td></tr>
<tr class="memdesc:aeee0c819cf8db4e63d7c8090d9fc0946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the contents of another string to this string.  <a href="#aeee0c819cf8db4e63d7c8090d9fc0946">More...</a><br/></td></tr>
<tr class="separator:aeee0c819cf8db4e63d7c8090d9fc0946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab565c26bfcfe7834ccef58029def6ce0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ab565c26bfcfe7834ccef58029def6ce0">append</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String)</td></tr>
<tr class="memdesc:ab565c26bfcfe7834ccef58029def6ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the contents of another string to this string.  <a href="#ab565c26bfcfe7834ccef58029def6ce0">More...</a><br/></td></tr>
<tr class="separator:ab565c26bfcfe7834ccef58029def6ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad094af4b3e514b9c663ff1c06c00d760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ad094af4b3e514b9c663ff1c06c00d760">append</a> (const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;utf8Character)</td></tr>
<tr class="memdesc:ad094af4b3e514b9c663ff1c06c00d760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a UTF-8 character to this string.  <a href="#ad094af4b3e514b9c663ff1c06c00d760">More...</a><br/></td></tr>
<tr class="separator:ad094af4b3e514b9c663ff1c06c00d760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141f697f06cafabeb9ce6ee5b5d2eb35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a141f697f06cafabeb9ce6ee5b5d2eb35">assign</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String)</td></tr>
<tr class="memdesc:a141f697f06cafabeb9ce6ee5b5d2eb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of another string to this string, replacing the current contents of this string.  <a href="#a141f697f06cafabeb9ce6ee5b5d2eb35">More...</a><br/></td></tr>
<tr class="separator:a141f697f06cafabeb9ce6ee5b5d2eb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c37e42777a33b69f20c8d61f701ed7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a2c37e42777a33b69f20c8d61f701ed7a">assign</a> (const std::string &amp;utf8String)</td></tr>
<tr class="memdesc:a2c37e42777a33b69f20c8d61f701ed7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of another string to this string, replacing the current contents of this string.  <a href="#a2c37e42777a33b69f20c8d61f701ed7a">More...</a><br/></td></tr>
<tr class="separator:a2c37e42777a33b69f20c8d61f701ed7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134d6d7218cee31fc5121eb9ee130fb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a134d6d7218cee31fc5121eb9ee130fb0">assign</a> (const char *utf8String)</td></tr>
<tr class="memdesc:a134d6d7218cee31fc5121eb9ee130fb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of another string to this string, replacing the current contents of this string.  <a href="#a134d6d7218cee31fc5121eb9ee130fb0">More...</a><br/></td></tr>
<tr class="separator:a134d6d7218cee31fc5121eb9ee130fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbab7fa2ef6f36e6e66765ed714f5701"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#afbab7fa2ef6f36e6e66765ed714f5701">assign</a> (const char *utf8String, const size_t codeUnitCount)</td></tr>
<tr class="memdesc:afbab7fa2ef6f36e6e66765ed714f5701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of another string to this string, replacing the current contents of this string.  <a href="#afbab7fa2ef6f36e6e66765ed714f5701">More...</a><br/></td></tr>
<tr class="separator:afbab7fa2ef6f36e6e66765ed714f5701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4869f2ec222e159911695a51ce7995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a4d4869f2ec222e159911695a51ce7995">assign</a> (const wchar_t *wideString)</td></tr>
<tr class="memdesc:a4d4869f2ec222e159911695a51ce7995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of another string to this string, replacing the current contents of this string.  <a href="#a4d4869f2ec222e159911695a51ce7995">More...</a><br/></td></tr>
<tr class="separator:a4d4869f2ec222e159911695a51ce7995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b90aa9a2958a4f5f0579d0aea46e3e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a4b90aa9a2958a4f5f0579d0aea46e3e9">assign</a> (const wchar_t *wideString, const size_t characterCount)</td></tr>
<tr class="memdesc:a4b90aa9a2958a4f5f0579d0aea46e3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of another string to this string, replacing the current contents of this string.  <a href="#a4b90aa9a2958a4f5f0579d0aea46e3e9">More...</a><br/></td></tr>
<tr class="separator:a4b90aa9a2958a4f5f0579d0aea46e3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462bb58470cb6255dfb9379c55ad16f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a462bb58470cb6255dfb9379c55ad16f9">assign</a> (const std::wstring &amp;wideString)</td></tr>
<tr class="memdesc:a462bb58470cb6255dfb9379c55ad16f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of another string to this string, replacing the current contents of this string.  <a href="#a462bb58470cb6255dfb9379c55ad16f9">More...</a><br/></td></tr>
<tr class="separator:a462bb58470cb6255dfb9379c55ad16f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4443d5e31d69f6603f170def4ec56810"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a4443d5e31d69f6603f170def4ec56810">assign</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String)</td></tr>
<tr class="memdesc:a4443d5e31d69f6603f170def4ec56810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of another string to this string, replacing the current contents of this string.  <a href="#a4443d5e31d69f6603f170def4ec56810">More...</a><br/></td></tr>
<tr class="separator:a4443d5e31d69f6603f170def4ec56810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7a8fd97ed94745d49f8b272394f260"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a5b7a8fd97ed94745d49f8b272394f260">assign</a> (const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;utf8Character)</td></tr>
<tr class="memdesc:a5b7a8fd97ed94745d49f8b272394f260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a UTF-8 character to this string.  <a href="#a5b7a8fd97ed94745d49f8b272394f260">More...</a><br/></td></tr>
<tr class="separator:a5b7a8fd97ed94745d49f8b272394f260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bf3a2a99adab53783b25952f4511b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_utf8_char_reference.html">Utf8CharReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#aa2bf3a2a99adab53783b25952f4511b1">at</a> (size_t index)</td></tr>
<tr class="memdesc:aa2bf3a2a99adab53783b25952f4511b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the character found at the specified character index.  <a href="#aa2bf3a2a99adab53783b25952f4511b1">More...</a><br/></td></tr>
<tr class="separator:aa2bf3a2a99adab53783b25952f4511b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80d6fe180b7a4273ae6b02f18e90f10"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#af80d6fe180b7a4273ae6b02f18e90f10">at</a> (size_t index) const </td></tr>
<tr class="memdesc:af80d6fe180b7a4273ae6b02f18e90f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the character found at the specified character index.  <a href="#af80d6fe180b7a4273ae6b02f18e90f10">More...</a><br/></td></tr>
<tr class="separator:af80d6fe180b7a4273ae6b02f18e90f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3598b0f6821403855665c64a09bdc908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a3598b0f6821403855665c64a09bdc908">begin</a> ()</td></tr>
<tr class="memdesc:a3598b0f6821403855665c64a09bdc908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first character of a string.  <a href="#a3598b0f6821403855665c64a09bdc908">More...</a><br/></td></tr>
<tr class="separator:a3598b0f6821403855665c64a09bdc908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93a035fba4984bd521937a391e58f7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_utf8_string_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#af93a035fba4984bd521937a391e58f7f">begin</a> () const </td></tr>
<tr class="memdesc:af93a035fba4984bd521937a391e58f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the first character of a string.  <a href="#af93a035fba4984bd521937a391e58f7f">More...</a><br/></td></tr>
<tr class="separator:af93a035fba4984bd521937a391e58f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08f897fb5c37039626c6f8130afa36f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ae08f897fb5c37039626c6f8130afa36f">c_str</a> () const </td></tr>
<tr class="memdesc:ae08f897fb5c37039626c6f8130afa36f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns c-style version of this string as an array of 8-bit code units.  <a href="#ae08f897fb5c37039626c6f8130afa36f">More...</a><br/></td></tr>
<tr class="separator:ae08f897fb5c37039626c6f8130afa36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ff9e9f4644060a75d195cb3f2b1b4a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ae5ff9e9f4644060a75d195cb3f2b1b4a">capacity</a> () const </td></tr>
<tr class="memdesc:ae5ff9e9f4644060a75d195cb3f2b1b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the largest number of code units that can be stored in this string without increasing the memory allocation of this string.  <a href="#ae5ff9e9f4644060a75d195cb3f2b1b4a">More...</a><br/></td></tr>
<tr class="separator:ae5ff9e9f4644060a75d195cb3f2b1b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7115394989a65f6c8a02e5472e83649f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7115394989a65f6c8a02e5472e83649f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a7115394989a65f6c8a02e5472e83649f">clear</a> ()</td></tr>
<tr class="memdesc:a7115394989a65f6c8a02e5472e83649f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears out the string, leaving it an empty string. <br/></td></tr>
<tr class="separator:a7115394989a65f6c8a02e5472e83649f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eaa9f2a819c165840ae7b670c02f8f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ac1eaa9f2a819c165840ae7b670c02f8f">code_unit_index</a> (const size_t codePointIndex)</td></tr>
<tr class="memdesc:ac1eaa9f2a819c165840ae7b670c02f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the index of a code point to the index of that code point's first code unit.  <a href="#ac1eaa9f2a819c165840ae7b670c02f8f">More...</a><br/></td></tr>
<tr class="separator:ac1eaa9f2a819c165840ae7b670c02f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758325e87dfd96fac84945e5266861c1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a758325e87dfd96fac84945e5266861c1">code_point_index</a> (const size_t codeUnitIndex)</td></tr>
<tr class="memdesc:a758325e87dfd96fac84945e5266861c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the index of a code unit to the index of the corresponding code point.  <a href="#a758325e87dfd96fac84945e5266861c1">More...</a><br/></td></tr>
<tr class="separator:a758325e87dfd96fac84945e5266861c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5038bfa65448466698eb06d6a82355"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#afe5038bfa65448466698eb06d6a82355">compare</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String) const </td></tr>
<tr class="memdesc:afe5038bfa65448466698eb06d6a82355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other.  <a href="#afe5038bfa65448466698eb06d6a82355">More...</a><br/></td></tr>
<tr class="separator:afe5038bfa65448466698eb06d6a82355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42c364d4afbfa4ada3ff385be5227be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ac42c364d4afbfa4ada3ff385be5227be">compare</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String) const </td></tr>
<tr class="memdesc:ac42c364d4afbfa4ada3ff385be5227be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other.  <a href="#ac42c364d4afbfa4ada3ff385be5227be">More...</a><br/></td></tr>
<tr class="separator:ac42c364d4afbfa4ada3ff385be5227be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64781029f89bbe02c35a8101e9e2144f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a64781029f89bbe02c35a8101e9e2144f">compare</a> (const std::string &amp;utf8String) const </td></tr>
<tr class="memdesc:a64781029f89bbe02c35a8101e9e2144f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other.  <a href="#a64781029f89bbe02c35a8101e9e2144f">More...</a><br/></td></tr>
<tr class="separator:a64781029f89bbe02c35a8101e9e2144f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6789f9f61eac12dbdcc207c8ea8d2f1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a6789f9f61eac12dbdcc207c8ea8d2f1e">compare</a> (const char *utf8String) const </td></tr>
<tr class="memdesc:a6789f9f61eac12dbdcc207c8ea8d2f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other.  <a href="#a6789f9f61eac12dbdcc207c8ea8d2f1e">More...</a><br/></td></tr>
<tr class="separator:a6789f9f61eac12dbdcc207c8ea8d2f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbb7f928c6297cf64538e74da5f41a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#affbb7f928c6297cf64538e74da5f41a0">compare</a> (const char *utf8String, const size_t codeUnitCount) const </td></tr>
<tr class="memdesc:affbb7f928c6297cf64538e74da5f41a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other.  <a href="#affbb7f928c6297cf64538e74da5f41a0">More...</a><br/></td></tr>
<tr class="separator:affbb7f928c6297cf64538e74da5f41a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4ee32100bba5c5daf214781f96f830"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a2f4ee32100bba5c5daf214781f96f830">copy</a> (char *codeUnitArray, const size_t codeUnitArraySize, const size_t characterCount, const size_t characterOffset=0) const </td></tr>
<tr class="memdesc:a2f4ee32100bba5c5daf214781f96f830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies at most a specific number of code points in this string into an array of code units.  <a href="#a2f4ee32100bba5c5daf214781f96f830">More...</a><br/></td></tr>
<tr class="separator:a2f4ee32100bba5c5daf214781f96f830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc768fd81bbcff6e3466610918d1d3f9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#afc768fd81bbcff6e3466610918d1d3f9">data</a> () const </td></tr>
<tr class="memdesc:afc768fd81bbcff6e3466610918d1d3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer an array of 8-bit code units containing the contents of this string.  <a href="#afc768fd81bbcff6e3466610918d1d3f9">More...</a><br/></td></tr>
<tr class="separator:afc768fd81bbcff6e3466610918d1d3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b16ea36e810f7aeb61e7b63ac00aa2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a97b16ea36e810f7aeb61e7b63ac00aa2">empty</a> () const </td></tr>
<tr class="memdesc:a97b16ea36e810f7aeb61e7b63ac00aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this string is empty.  <a href="#a97b16ea36e810f7aeb61e7b63ac00aa2">More...</a><br/></td></tr>
<tr class="separator:a97b16ea36e810f7aeb61e7b63ac00aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63b4fae695581535f96725f03003e01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ac63b4fae695581535f96725f03003e01">end</a> ()</td></tr>
<tr class="memdesc:ac63b4fae695581535f96725f03003e01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the location succeeding the last character in a string.  <a href="#ac63b4fae695581535f96725f03003e01">More...</a><br/></td></tr>
<tr class="separator:ac63b4fae695581535f96725f03003e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e74162261a52a1ec432fc77a1dfb38d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_utf8_string_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a7e74162261a52a1ec432fc77a1dfb38d">end</a> () const </td></tr>
<tr class="memdesc:a7e74162261a52a1ec432fc77a1dfb38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an constant iterator pointing to the location succeeding the last character in a string.  <a href="#a7e74162261a52a1ec432fc77a1dfb38d">More...</a><br/></td></tr>
<tr class="separator:a7e74162261a52a1ec432fc77a1dfb38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fecf169b2cf76feaefc0d3b957fc4a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a4fecf169b2cf76feaefc0d3b957fc4a0">erase</a> (const <a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a> &amp;firstPosition, const <a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a> &amp;lastPosition)</td></tr>
<tr class="memdesc:a4fecf169b2cf76feaefc0d3b957fc4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a range of characters from this string.  <a href="#a4fecf169b2cf76feaefc0d3b957fc4a0">More...</a><br/></td></tr>
<tr class="separator:a4fecf169b2cf76feaefc0d3b957fc4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7452379795bf8897add1030f7ae200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#aae7452379795bf8897add1030f7ae200">erase</a> (const <a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a> &amp;position)</td></tr>
<tr class="memdesc:aae7452379795bf8897add1030f7ae200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a character from this string.  <a href="#aae7452379795bf8897add1030f7ae200">More...</a><br/></td></tr>
<tr class="separator:aae7452379795bf8897add1030f7ae200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1fdc97a5528f54dc3eb4ee2dae298f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a2c1fdc97a5528f54dc3eb4ee2dae298f">erase</a> (const size_t offset=0, const size_t count=<a class="el" href="struct_utf_string_1_1_utf8_string.html#ab6360100853a5b548ec1801fb1f435ae">npos</a>)</td></tr>
<tr class="memdesc:a2c1fdc97a5528f54dc3eb4ee2dae298f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a range of characters from this string.  <a href="#a2c1fdc97a5528f54dc3eb4ee2dae298f">More...</a><br/></td></tr>
<tr class="separator:a2c1fdc97a5528f54dc3eb4ee2dae298f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea28feab6aa3406e0b2bb133472d3cbb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#aea28feab6aa3406e0b2bb133472d3cbb">find</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;searchString, size_t offset=0)</td></tr>
<tr class="memdesc:aea28feab6aa3406e0b2bb133472d3cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for specific substring.  <a href="#aea28feab6aa3406e0b2bb133472d3cbb">More...</a><br/></td></tr>
<tr class="separator:aea28feab6aa3406e0b2bb133472d3cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee278d89decd987ea95067f3bbb88b8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a4ee278d89decd987ea95067f3bbb88b8">find_first_not_of</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;searchString, size_t offset=0)</td></tr>
<tr class="memdesc:a4ee278d89decd987ea95067f3bbb88b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the first character that is not found in a given string.  <a href="#a4ee278d89decd987ea95067f3bbb88b8">More...</a><br/></td></tr>
<tr class="separator:a4ee278d89decd987ea95067f3bbb88b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f4018ceaa79c356b926f803ed40ca8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ad3f4018ceaa79c356b926f803ed40ca8">find_first_of</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;searchString, size_t offset=0)</td></tr>
<tr class="memdesc:ad3f4018ceaa79c356b926f803ed40ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the first character that is found in a given string.  <a href="#ad3f4018ceaa79c356b926f803ed40ca8">More...</a><br/></td></tr>
<tr class="separator:ad3f4018ceaa79c356b926f803ed40ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6482960ae19d0f5c119369daf3a21f0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ae6482960ae19d0f5c119369daf3a21f0">find_last_not_of</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;searchString, size_t offset=<a class="el" href="struct_utf_string_1_1_utf8_string.html#ab6360100853a5b548ec1801fb1f435ae">npos</a>)</td></tr>
<tr class="memdesc:ae6482960ae19d0f5c119369daf3a21f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the last character that is not found in a given string.  <a href="#ae6482960ae19d0f5c119369daf3a21f0">More...</a><br/></td></tr>
<tr class="separator:ae6482960ae19d0f5c119369daf3a21f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ca9a0e754196d1ff8c3bdd4e4d1e70"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#af3ca9a0e754196d1ff8c3bdd4e4d1e70">find_last_of</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;searchString, size_t offset=<a class="el" href="struct_utf_string_1_1_utf8_string.html#ab6360100853a5b548ec1801fb1f435ae">npos</a>)</td></tr>
<tr class="memdesc:af3ca9a0e754196d1ff8c3bdd4e4d1e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the last character that is found in a given string.  <a href="#af3ca9a0e754196d1ff8c3bdd4e4d1e70">More...</a><br/></td></tr>
<tr class="separator:af3ca9a0e754196d1ff8c3bdd4e4d1e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922265c008dce096bd3d601cdf5442ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a922265c008dce096bd3d601cdf5442ee">insert</a> (const size_t index, const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String)</td></tr>
<tr class="memdesc:a922265c008dce096bd3d601cdf5442ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the contents of another string into this string at a specified index.  <a href="#a922265c008dce096bd3d601cdf5442ee">More...</a><br/></td></tr>
<tr class="separator:a922265c008dce096bd3d601cdf5442ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c288039647bb6e9743f8701f97cc558"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a9c288039647bb6e9743f8701f97cc558">insert</a> (const size_t index, const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String)</td></tr>
<tr class="memdesc:a9c288039647bb6e9743f8701f97cc558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the contents of another string into this string at a specified index.  <a href="#a9c288039647bb6e9743f8701f97cc558">More...</a><br/></td></tr>
<tr class="separator:a9c288039647bb6e9743f8701f97cc558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587c270802c8e143fdf3728f0265dcf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a587c270802c8e143fdf3728f0265dcf0">insert</a> (const size_t index, const std::string &amp;utf8String)</td></tr>
<tr class="memdesc:a587c270802c8e143fdf3728f0265dcf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the contents of another string into this string at a specified index.  <a href="#a587c270802c8e143fdf3728f0265dcf0">More...</a><br/></td></tr>
<tr class="separator:a587c270802c8e143fdf3728f0265dcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbb7a410ecf77c75aa8f409bf642556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a2bbb7a410ecf77c75aa8f409bf642556">insert</a> (const size_t index, const char *utf8String)</td></tr>
<tr class="memdesc:a2bbb7a410ecf77c75aa8f409bf642556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the contents of another string into this string at a specified index.  <a href="#a2bbb7a410ecf77c75aa8f409bf642556">More...</a><br/></td></tr>
<tr class="separator:a2bbb7a410ecf77c75aa8f409bf642556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d97ce4ad6a27d4205ae27ecd8b02b3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a2d97ce4ad6a27d4205ae27ecd8b02b3e">insert</a> (const size_t index, const char *utf8String, const size_t codeUnitCount)</td></tr>
<tr class="memdesc:a2d97ce4ad6a27d4205ae27ecd8b02b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the contents of another string into this string at a specified index.  <a href="#a2d97ce4ad6a27d4205ae27ecd8b02b3e">More...</a><br/></td></tr>
<tr class="separator:a2d97ce4ad6a27d4205ae27ecd8b02b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d5e8d009d929ce320219004eaed2fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ab8d5e8d009d929ce320219004eaed2fe">insert</a> (const size_t index, const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;utf8Character)</td></tr>
<tr class="memdesc:ab8d5e8d009d929ce320219004eaed2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a character into this string at a specified index.  <a href="#ab8d5e8d009d929ce320219004eaed2fe">More...</a><br/></td></tr>
<tr class="separator:ab8d5e8d009d929ce320219004eaed2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8427b3c37edfdba9b3981ff401d5a384"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a8427b3c37edfdba9b3981ff401d5a384">is_valid</a> () const </td></tr>
<tr class="memdesc:a8427b3c37edfdba9b3981ff401d5a384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the code units in this string comprise a valid UTF-8 string.  <a href="#a8427b3c37edfdba9b3981ff401d5a384">More...</a><br/></td></tr>
<tr class="separator:a8427b3c37edfdba9b3981ff401d5a384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518584516f646c27f1b3abead0923930"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a518584516f646c27f1b3abead0923930">length</a> () const </td></tr>
<tr class="memdesc:a518584516f646c27f1b3abead0923930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of code points in this string.  <a href="#a518584516f646c27f1b3abead0923930">More...</a><br/></td></tr>
<tr class="separator:a518584516f646c27f1b3abead0923930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294cde176dd9e86277839671800ee5ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a294cde176dd9e86277839671800ee5ca">push_back</a> (const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;character)</td></tr>
<tr class="memdesc:a294cde176dd9e86277839671800ee5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a character to the end of this string.  <a href="#a294cde176dd9e86277839671800ee5ca">More...</a><br/></td></tr>
<tr class="separator:a294cde176dd9e86277839671800ee5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8fc579435d2a12db6a8e3b4af1f648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_utf8_string_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a4b8fc579435d2a12db6a8e3b4af1f648">rbegin</a> ()</td></tr>
<tr class="memdesc:a4b8fc579435d2a12db6a8e3b4af1f648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first character of a reversed string, which corresponds to the last character of the normal string.  <a href="#a4b8fc579435d2a12db6a8e3b4af1f648">More...</a><br/></td></tr>
<tr class="separator:a4b8fc579435d2a12db6a8e3b4af1f648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018a66e6b3d0192935f82453cee55269"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_utf8_string_1_1const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a018a66e6b3d0192935f82453cee55269">rbegin</a> () const </td></tr>
<tr class="memdesc:a018a66e6b3d0192935f82453cee55269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the first character of a reversed string, which corresponds to the last character of a normal string.  <a href="#a018a66e6b3d0192935f82453cee55269">More...</a><br/></td></tr>
<tr class="separator:a018a66e6b3d0192935f82453cee55269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27adb94911202726b7bb239aed6918c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_utf8_string_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a27adb94911202726b7bb239aed6918c3">rend</a> ()</td></tr>
<tr class="memdesc:a27adb94911202726b7bb239aed6918c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the location succeeding the last character in a reversed string, which corresponds to the location preceding the first character in a normal string.  <a href="#a27adb94911202726b7bb239aed6918c3">More...</a><br/></td></tr>
<tr class="separator:a27adb94911202726b7bb239aed6918c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d453a90ce2e37f486e2359f0fc352c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_utf8_string_1_1const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#aa1d453a90ce2e37f486e2359f0fc352c">rend</a> () const </td></tr>
<tr class="memdesc:aa1d453a90ce2e37f486e2359f0fc352c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an constant iterator pointing to the location succeeding the last character in a reversed string, which corresponds to the location preceding the first character in a normal string.  <a href="#aa1d453a90ce2e37f486e2359f0fc352c">More...</a><br/></td></tr>
<tr class="separator:aa1d453a90ce2e37f486e2359f0fc352c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1457d47462c3281ba7abfae9d5c8e824"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a1457d47462c3281ba7abfae9d5c8e824">replace</a> (const size_t position, const size_t count, const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;replacementString)</td></tr>
<tr class="memdesc:a1457d47462c3281ba7abfae9d5c8e824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a section of this string and replaces it with the contents of another string.  <a href="#a1457d47462c3281ba7abfae9d5c8e824">More...</a><br/></td></tr>
<tr class="separator:a1457d47462c3281ba7abfae9d5c8e824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf7e554fe572752b1333df55a0a09a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#afaf7e554fe572752b1333df55a0a09a5">replace</a> (const size_t position, const size_t count, const size_t characterCount, const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;character)</td></tr>
<tr class="memdesc:afaf7e554fe572752b1333df55a0a09a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in a section of this string with the given character.  <a href="#afaf7e554fe572752b1333df55a0a09a5">More...</a><br/></td></tr>
<tr class="separator:afaf7e554fe572752b1333df55a0a09a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0754934a75b663056a35ea5df110144c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a0754934a75b663056a35ea5df110144c">replace</a> (<a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a> beginIterator, <a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a> endIterator, const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;replacementString)</td></tr>
<tr class="memdesc:a0754934a75b663056a35ea5df110144c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a section of this string and replaces it with the contents of another string.  <a href="#a0754934a75b663056a35ea5df110144c">More...</a><br/></td></tr>
<tr class="separator:a0754934a75b663056a35ea5df110144c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b8f5db00982fc92ed6496f9423c9da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a89b8f5db00982fc92ed6496f9423c9da">replace</a> (<a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a> beginIterator, <a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a> endIterator, const size_t characterCount, const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;character)</td></tr>
<tr class="memdesc:a89b8f5db00982fc92ed6496f9423c9da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in a section of this string with the given character.  <a href="#a89b8f5db00982fc92ed6496f9423c9da">More...</a><br/></td></tr>
<tr class="separator:a89b8f5db00982fc92ed6496f9423c9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ba6243cff966e290d56e3034483dea"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a77ba6243cff966e290d56e3034483dea">rfind</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;searchString, size_t offset=<a class="el" href="struct_utf_string_1_1_utf8_string.html#ab6360100853a5b548ec1801fb1f435ae">npos</a>)</td></tr>
<tr class="memdesc:a77ba6243cff966e290d56e3034483dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string backward for specific substring.  <a href="#a77ba6243cff966e290d56e3034483dea">More...</a><br/></td></tr>
<tr class="separator:a77ba6243cff966e290d56e3034483dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cda0778146d0fe1623904e57b9188e5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a4cda0778146d0fe1623904e57b9188e5">size</a> () const </td></tr>
<tr class="memdesc:a4cda0778146d0fe1623904e57b9188e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of code units in this string.  <a href="#a4cda0778146d0fe1623904e57b9188e5">More...</a><br/></td></tr>
<tr class="separator:a4cda0778146d0fe1623904e57b9188e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b32a8159e4800d99e0c14fc028bf073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a0b32a8159e4800d99e0c14fc028bf073">substr</a> (const size_t offset=0, const size_t count=<a class="el" href="struct_utf_string_1_1_utf8_string.html#ab6360100853a5b548ec1801fb1f435ae">npos</a>)</td></tr>
<tr class="memdesc:a0b32a8159e4800d99e0c14fc028bf073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring of this string.  <a href="#a0b32a8159e4800d99e0c14fc028bf073">More...</a><br/></td></tr>
<tr class="separator:a0b32a8159e4800d99e0c14fc028bf073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49b591a7db63b8d8f5a3dd1a7c30269"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ab49b591a7db63b8d8f5a3dd1a7c30269">swap</a> (<a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String)</td></tr>
<tr class="memdesc:ab49b591a7db63b8d8f5a3dd1a7c30269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this string with those of another string.  <a href="#ab49b591a7db63b8d8f5a3dd1a7c30269">More...</a><br/></td></tr>
<tr class="separator:ab49b591a7db63b8d8f5a3dd1a7c30269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8698fcbb8b88f7a7a97e67c146d660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_utf8_char_reference.html">Utf8CharReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a3a8698fcbb8b88f7a7a97e67c146d660">operator[]</a> (const size_t index)</td></tr>
<tr class="memdesc:a3a8698fcbb8b88f7a7a97e67c146d660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character found at the specified character index.  <a href="#a3a8698fcbb8b88f7a7a97e67c146d660">More...</a><br/></td></tr>
<tr class="separator:a3a8698fcbb8b88f7a7a97e67c146d660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad04c2f625775e0a5afa3ba9ff50fa0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#afad04c2f625775e0a5afa3ba9ff50fa0">operator[]</a> (const size_t index) const </td></tr>
<tr class="memdesc:afad04c2f625775e0a5afa3ba9ff50fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character found at the specified character index.  <a href="#afad04c2f625775e0a5afa3ba9ff50fa0">More...</a><br/></td></tr>
<tr class="separator:afad04c2f625775e0a5afa3ba9ff50fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396d76ea0929c8b06c6954f028675114"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a396d76ea0929c8b06c6954f028675114">operator==</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;otherString) const </td></tr>
<tr class="memdesc:a396d76ea0929c8b06c6954f028675114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of another string and tests whether the two strings are the same.  <a href="#a396d76ea0929c8b06c6954f028675114">More...</a><br/></td></tr>
<tr class="separator:a396d76ea0929c8b06c6954f028675114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e1bd5744d98272854fe30eb8894b7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#af9e1bd5744d98272854fe30eb8894b7a">operator!=</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;otherString) const </td></tr>
<tr class="memdesc:af9e1bd5744d98272854fe30eb8894b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of another string and tests whether the two strings are the different.  <a href="#af9e1bd5744d98272854fe30eb8894b7a">More...</a><br/></td></tr>
<tr class="separator:af9e1bd5744d98272854fe30eb8894b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c61cb8870265b214449fed9e3620a33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a8c61cb8870265b214449fed9e3620a33">operator&lt;</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;otherString) const </td></tr>
<tr class="memdesc:a8c61cb8870265b214449fed9e3620a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of another string and tests whether the value of this string is less than the value of the other string.  <a href="#a8c61cb8870265b214449fed9e3620a33">More...</a><br/></td></tr>
<tr class="separator:a8c61cb8870265b214449fed9e3620a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab324833151cb5ac0e622764196095180"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ab324833151cb5ac0e622764196095180">operator&lt;=</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;otherString) const </td></tr>
<tr class="memdesc:ab324833151cb5ac0e622764196095180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of another string and tests whether the value of this string is less than or equal to the value of the other string.  <a href="#ab324833151cb5ac0e622764196095180">More...</a><br/></td></tr>
<tr class="separator:ab324833151cb5ac0e622764196095180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9899daa4d9093285d21c3adad5476b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ac9899daa4d9093285d21c3adad5476b8">operator&gt;</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;otherString) const </td></tr>
<tr class="memdesc:ac9899daa4d9093285d21c3adad5476b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of another string and tests whether the value of this string is greater than the value of the other string.  <a href="#ac9899daa4d9093285d21c3adad5476b8">More...</a><br/></td></tr>
<tr class="separator:ac9899daa4d9093285d21c3adad5476b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6677b1c67bf291781ae07c565e357724"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a6677b1c67bf291781ae07c565e357724">operator&gt;=</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;otherString) const </td></tr>
<tr class="memdesc:a6677b1c67bf291781ae07c565e357724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of another string and tests whether the value of this string is greater than or equal to the value of the other string.  <a href="#a6677b1c67bf291781ae07c565e357724">More...</a><br/></td></tr>
<tr class="separator:a6677b1c67bf291781ae07c565e357724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fe214604285f628b8559028c3a2913"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7fe214604285f628b8559028c3a2913"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ad7fe214604285f628b8559028c3a2913">operator const std::string</a> () const </td></tr>
<tr class="memdesc:ad7fe214604285f628b8559028c3a2913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object to a std::string const instance. <br/></td></tr>
<tr class="separator:ad7fe214604285f628b8559028c3a2913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab33c0d389a4f6145eb841da93acd06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ab33c0d389a4f6145eb841da93acd06"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a0ab33c0d389a4f6145eb841da93acd06">operator std::string</a> ()</td></tr>
<tr class="memdesc:a0ab33c0d389a4f6145eb841da93acd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object to a std::string instance. <br/></td></tr>
<tr class="separator:a0ab33c0d389a4f6145eb841da93acd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4a0bb93367a5dd328ba80924e50fe77b"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a4a0bb93367a5dd328ba80924e50fe77b">CharacterCodeUnitCount</a> (const std::string::const_iterator stringIterator)</td></tr>
<tr class="memdesc:a4a0bb93367a5dd328ba80924e50fe77b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of code units in the character that the string iterator is pointing to.  <a href="#a4a0bb93367a5dd328ba80924e50fe77b">More...</a><br/></td></tr>
<tr class="separator:a4a0bb93367a5dd328ba80924e50fe77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ed159b5072bc40e77ae5fad0911979"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ab2ed159b5072bc40e77ae5fad0911979">CharacterCodeUnitCount</a> (const std::string::const_reverse_iterator &amp;stringIterator)</td></tr>
<tr class="memdesc:ab2ed159b5072bc40e77ae5fad0911979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of code units in the character that the string reverse iterator is pointing to.  <a href="#ab2ed159b5072bc40e77ae5fad0911979">More...</a><br/></td></tr>
<tr class="separator:ab2ed159b5072bc40e77ae5fad0911979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20c7e3e5c9144ac17cc34b8914abc46"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ae20c7e3e5c9144ac17cc34b8914abc46">CharacterCodeUnitCount</a> (const char *characterPointer)</td></tr>
<tr class="memdesc:ae20c7e3e5c9144ac17cc34b8914abc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of code units in the character that a character pointer is pointing to.  <a href="#ae20c7e3e5c9144ac17cc34b8914abc46">More...</a><br/></td></tr>
<tr class="separator:ae20c7e3e5c9144ac17cc34b8914abc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34e6c5c2e00787fe5eb656f51bb8667"><td class="memItemLeft" align="right" valign="top">static UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ad34e6c5c2e00787fe5eb656f51bb8667">DecodeCharacter</a> (const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;utf8Character)</td></tr>
<tr class="memdesc:ad34e6c5c2e00787fe5eb656f51bb8667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a UTF-8 character, returning the result as a 32-bit code point.  <a href="#ad34e6c5c2e00787fe5eb656f51bb8667">More...</a><br/></td></tr>
<tr class="separator:ad34e6c5c2e00787fe5eb656f51bb8667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80506a324f729d0c2004a1e63ac5499"><td class="memItemLeft" align="right" valign="top">static UInt32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#af80506a324f729d0c2004a1e63ac5499">DecodeCharacter</a> (const char *characterPointer, const size_t codeUnitCount)</td></tr>
<tr class="memdesc:af80506a324f729d0c2004a1e63ac5499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a UTF-8 character, returning the result as a 32-bit code point.  <a href="#af80506a324f729d0c2004a1e63ac5499">More...</a><br/></td></tr>
<tr class="separator:af80506a324f729d0c2004a1e63ac5499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc70110c13c512171130d0db33fdc6c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#abfc70110c13c512171130d0db33fdc6c">EncodeCharacter</a> (const UInt32 codePoint)</td></tr>
<tr class="memdesc:abfc70110c13c512171130d0db33fdc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes a 32-bit code point as a UTF-8 character.  <a href="#abfc70110c13c512171130d0db33fdc6c">More...</a><br/></td></tr>
<tr class="separator:abfc70110c13c512171130d0db33fdc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996e22f5c05348d18b3856b8bb449461"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a996e22f5c05348d18b3856b8bb449461">IsValidCharacter</a> (const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;utf8Character)</td></tr>
<tr class="memdesc:a996e22f5c05348d18b3856b8bb449461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether a series of 8-bit code units is a valid UTF-8 character.  <a href="#a996e22f5c05348d18b3856b8bb449461">More...</a><br/></td></tr>
<tr class="separator:a996e22f5c05348d18b3856b8bb449461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bcc7a338352c15400353f3ab66a647"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ab0bcc7a338352c15400353f3ab66a647">IsValidCharacter</a> (const char *characterPointer, const size_t codeUnitCount)</td></tr>
<tr class="memdesc:ab0bcc7a338352c15400353f3ab66a647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether a series of 8-bit code units is a valid UTF-8 character.  <a href="#ab0bcc7a338352c15400353f3ab66a647">More...</a><br/></td></tr>
<tr class="separator:ab0bcc7a338352c15400353f3ab66a647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e36ba72528de7079e560936857cefcf"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a5e36ba72528de7079e560936857cefcf">IsWhitespace</a> (const char *utf8Character, const size_t codeUnitCount)</td></tr>
<tr class="memdesc:a5e36ba72528de7079e560936857cefcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether a UTF-8 character is a whitespace character.  <a href="#a5e36ba72528de7079e560936857cefcf">More...</a><br/></td></tr>
<tr class="separator:a5e36ba72528de7079e560936857cefcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0641f10d0bec2bfe21fd5d02038f2b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#aec0641f10d0bec2bfe21fd5d02038f2b">IsWhitespace</a> (const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;utf8Character)</td></tr>
<tr class="memdesc:aec0641f10d0bec2bfe21fd5d02038f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether a UTF-8 character is a whitespace character.  <a href="#aec0641f10d0bec2bfe21fd5d02038f2b">More...</a><br/></td></tr>
<tr class="separator:aec0641f10d0bec2bfe21fd5d02038f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab6360100853a5b548ec1801fb1f435ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6360100853a5b548ec1801fb1f435ae"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#ab6360100853a5b548ec1801fb1f435ae">npos</a></td></tr>
<tr class="memdesc:ab6360100853a5b548ec1801fb1f435ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned integral value initialized to 1 that indicates either "not found" or "all remaining characters" when a search function fails. <br/></td></tr>
<tr class="separator:ab6360100853a5b548ec1801fb1f435ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a50c42b5ce8de9eb5c9d2635b76fb01f5"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#a50c42b5ce8de9eb5c9d2635b76fb01f5">operator&gt;&gt;</a> (std::istream &amp;inputStream, <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String)</td></tr>
<tr class="memdesc:a50c42b5ce8de9eb5c9d2635b76fb01f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator converts a stream of 8-bit values to a UTF-8 string.  <a href="#a50c42b5ce8de9eb5c9d2635b76fb01f5">More...</a><br/></td></tr>
<tr class="separator:a50c42b5ce8de9eb5c9d2635b76fb01f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfdf11dff1931b8000b35967714b53bf"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_utf_string_1_1_utf8_string.html#acfdf11dff1931b8000b35967714b53bf">operator&lt;&lt;</a> (std::ostream &amp;outputStream, const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String)</td></tr>
<tr class="memdesc:acfdf11dff1931b8000b35967714b53bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator converts a UTF-8 string to a stream of 8-bit values.  <a href="#acfdf11dff1931b8000b35967714b53bf">More...</a><br/></td></tr>
<tr class="separator:acfdf11dff1931b8000b35967714b53bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains and manages a UTF-8 string. </p>
<p>This class inherits the STL std::string class. The std::string class can hold UTF-8 strings, but it becomes difficult to conduct any string operations on the UTF-8 string because UTF-8 has variable-length characters. The std::string class is best suited for fixed-length ASCII strings, hence why we need a separate class for UTF-8 strings. When accessing individual characters in a <a class="el" href="struct_utf_string_1_1_utf8_string.html" title="Contains and manages a UTF-8 string. ">Utf8String</a>, <a class="el" href="class_utf_string_1_1_utf8_char.html" title="Provides a copy of a UTF-8 character embedded in a UTF-8 string. ">Utf8Char</a> objects will be returned. A <a class="el" href="class_utf_string_1_1_utf8_char.html" title="Provides a copy of a UTF-8 character embedded in a UTF-8 string. ">Utf8Char</a> object contains a single UTF-8 character (also known as a code point) and the individual code units representing the UTF-8 character can be accessed if desired.</p>
<p>Endianness does not affect the UTF-8 string class. It stores the string as a sequence of 8-bit code units, which are unaffected by endianness. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aec7e62a25100d41ef82ed615d3d7a1de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UtfString::Utf8String::Utf8String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a string with the contents of another string as its initial value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string of 8-bit code units to be the initial value of the string that is being created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31c2a7f2e2f335cf2eaf3b8e7a56037d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UtfString::Utf8String::Utf8String </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a string with the contents of another string as its initial value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string of 8-bit code units to be the initial value of the string that is being created. The string is assumed to be a UTF-8 string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ab78a7f36c47473629e3e708d183015"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UtfString::Utf8String::Utf8String </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a string with the contents of another string as its initial value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string of 8-bit code units to be the initial value of the string that is being created. The string is assumed to be a UTF-8 string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad90920076979c72ab178b1c0d8094f23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UtfString::Utf8String::Utf8String </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8String</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>characterCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a string with the contents of another string as its initial value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string of 8-bit code units to be the initial value of the string that is being created. The string is assumed to be a UTF-8 string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">characterCount</td><td>The number of characters in utf8String to be used in initializing this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56014d2b38533d695623cc16192a0335"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UtfString::Utf8String::Utf8String </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a string with the contents of another string as its initial value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>A string of 16-bit code units to be the initial value of the string that is being created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2c7a580e1bd5f81aabe9ee1cd4fb257"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UtfString::Utf8String::Utf8String </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wideString</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a string with the contents of another string as its initial value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wideString</td><td>A string of wchar_t to be the initial value of the string that is being created. The string is assumed to be a UTF-16 string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7059b736d724926a3b9acb7cca1a10e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UtfString::Utf8String::Utf8String </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wideString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>characterCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a string with the contents of another string as its initial value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wideString</td><td>A string of wchar_t to be the initial value of the string that is being created. The string is assumed to be a UTF-16 string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">characterCount</td><td>The number of characters in wideString to be used in initializing this string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7506f235cb4aad1c434173a96c4a6b44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UtfString::Utf8String::Utf8String </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>wideString</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a string with the contents of another string as its initial value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wideString</td><td>A string wchar_t to be the initial value of the string that is being created. The string is assumed to be a UTF-16 string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a41eba4db2d896a6bebd34d8ae5b0bd3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the contents of another string to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string of 8-bit code units to be appended</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a4a94f7f94c6b459c0732d90d6f431896"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::append </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the contents of another string to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string of 8-bit code units to be appended. The string is assumed to be a valid UTF-8 string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a6c09e5973e16febd3ef785c0491682b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::append </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the contents of another string to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string of 8-bit code units to be appended. The string is assumed to be a valid UTF-8 string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a94723b64663189f12bbac3cdfb77e9c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::append </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8String</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>codeUnitCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the contents of another string to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string of 8-bit code units to be appended. The string is assumed to be a valid UTF-8 string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">codeUnitCount</td><td>The number of code units in utf8String to be appended</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a16c09bf8fa83942b97b573245a102482"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::append </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wideString</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the contents of another string to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wideString</td><td>A string of wchar_t to be appended. The string is assumed to be a valid UTF-16 string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="aa51f39ce19a23afddf8fa03ac1549b1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::append </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wideString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>characterCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the contents of another string to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wideString</td><td>A string of wchar_t to be appended. The string is assumed to be a valid UTF-16 string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">characterCount</td><td>The number of characters in wideString to be appended</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="aeee0c819cf8db4e63d7c8090d9fc0946"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::append </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>wideString</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the contents of another string to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wideString</td><td>A string wchar_t to be appended. The string is assumed to be a valid UTF-16 string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="ab565c26bfcfe7834ccef58029def6ce0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the contents of another string to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>A UTF-16 string to be appended. The string is assumed to be a valid UTF-16 string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="ad094af4b3e514b9c663ff1c06c00d760"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8Character</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a UTF-8 character to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8Character</td><td>A UTF-8 character to be appended.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a141f697f06cafabeb9ce6ee5b5d2eb35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the contents of another string to this string, replacing the current contents of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string of 8-bit code units to be assigned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a2c37e42777a33b69f20c8d61f701ed7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::assign </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the contents of another string to this string, replacing the current contents of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string of 8-bit code units to be assigned. The string is assumed to be a valid UTF-8 string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a134d6d7218cee31fc5121eb9ee130fb0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the contents of another string to this string, replacing the current contents of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string of 8-bit code units to be assigned. The string is assumed to be a valid UTF-8 string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="afbab7fa2ef6f36e6e66765ed714f5701"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8String</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>codeUnitCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the contents of another string to this string, replacing the current contents of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string of 8-bit code units to be assigned. The string is assumed to be a valid UTF-8 string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">codeUnitCount</td><td>The number of code units in utf8String to be assigned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a4d4869f2ec222e159911695a51ce7995"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::assign </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wideString</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the contents of another string to this string, replacing the current contents of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wideString</td><td>A string of wchar_t to be assigned. The string is assumed to be a valid UTF-16 string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a4b90aa9a2958a4f5f0579d0aea46e3e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::assign </td>
          <td>(</td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wideString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>characterCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the contents of another string to this string, replacing the current contents of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wideString</td><td>A string of wchar_t to be assigned. The string is assumed to be a valid UTF-16 string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">characterCount</td><td>The number of characters in wideString to be assigned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a462bb58470cb6255dfb9379c55ad16f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::assign </td>
          <td>(</td>
          <td class="paramtype">const std::wstring &amp;&#160;</td>
          <td class="paramname"><em>wideString</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the contents of another string to this string, replacing the current contents of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wideString</td><td>A string of wchar_t to be assigned. The string is assumed to be a valid UTF-16 string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a4443d5e31d69f6603f170def4ec56810"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the contents of another string to this string, replacing the current contents of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>A UTF-16 string to be assigned. The string is assumed to be a valid UTF-16 string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a5b7a8fd97ed94745d49f8b272394f260"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8Character</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a UTF-8 character to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8Character</td><td>A UTF-8 character to be assigned. The character is assumed to be a valid UTF-8 character</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="aa2bf3a2a99adab53783b25952f4511b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_utf8_char_reference.html">Utf8CharReference</a> UtfString::Utf8String::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the character found at the specified character index. </p>
<p>This operator does for the validity of the index, and throws an out_of_range exception when the given index doesn't correspond to a character within a string. Note that operator[] is a faster way to access a specific character, but doesn't check for index validity.</p>
<p>Note that unlike standard ASCII or UCS-2, which are fixed-length encodings, UTF-8 is a variable length encoding. This means that whereas accessing a character at a particular index is O(1) for fixed-length encodings, accessing a character in UTF-8 strings is O(1) in the best case and O(n) in the worst case.</p>
<p>So if you wish to iterate through the characters in this string, use the standard iterators instead of an indexer. The standard iterators will be far more efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of a character in the string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character found at the specified index </dd></dl>

</div>
</div>
<a class="anchor" id="af80d6fe180b7a4273ae6b02f18e90f10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> UtfString::Utf8String::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the character found at the specified character index. </p>
<p>This operator does for the validity of the index, and throws an out_of_range exception when the given index doesn't correspond to a character within a string. Note that operator[] is a faster way to access a specific character, but doesn't check for index validity.</p>
<p>Note that unlike standard ASCII or UCS-2, which are fixed-length encodings, UTF-8 is a variable length encoding. This means that whereas accessing a character at a particular index is O(1) for fixed-length encodings, accessing a character in UTF-8 strings is O(1) in the best case and O(n) in the worst case.</p>
<p>So if you wish to iterate through the characters in this string, use the standard iterators instead of an indexer. The standard iterators will be far more efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of a character in the string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character found at the specified index </dd></dl>

</div>
</div>
<a class="anchor" id="a3598b0f6821403855665c64a09bdc908"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">iterator</a> UtfString::Utf8String::begin </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first character of a string. </p>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional iterator pointing to the first character in a string or just beyond the end of an empty string </dd></dl>

</div>
</div>
<a class="anchor" id="af93a035fba4984bd521937a391e58f7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_utf8_string_1_1const__iterator.html">const_iterator</a> UtfString::Utf8String::begin </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the first character of a string. </p>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional constant iterator pointing to the first character in a string or just beyond the end of an empty string </dd></dl>

</div>
</div>
<a class="anchor" id="ae08f897fb5c37039626c6f8130afa36f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* UtfString::Utf8String::c_str </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns c-style version of this string as an array of 8-bit code units. </p>
<p>The c-style array is owned by this object, and the pointer returned by this function is invalidated if any non-const functions are called on this object.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a null-terminated array of 8-bit code units </dd></dl>

</div>
</div>
<a class="anchor" id="ae5ff9e9f4644060a75d195cb3f2b1b4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::Utf8String::capacity </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the largest number of code units that can be stored in this string without increasing the memory allocation of this string. </p>
<p>When characters are added to the string and there is no more memory available to the string, the string allocates a chunk of memory. Memory is allocated in chunks significantly larger than necessary, so that performance doesn't suffer from lots of memory-allocation operations when many characters are added. The capicity indicates how many code units the string currently has memory for. When <a class="el" href="struct_utf_string_1_1_utf8_string.html#a4cda0778146d0fe1623904e57b9188e5" title="Returns the number of code units in this string. ">size()</a> == <a class="el" href="struct_utf_string_1_1_utf8_string.html#ae5ff9e9f4644060a75d195cb3f2b1b4a" title="Returns the largest number of code units that can be stored in this string without increasing the mem...">capacity()</a>, adding any more characters will cause the string to allocate more memory. Note that in all cases, <a class="el" href="struct_utf_string_1_1_utf8_string.html#a4cda0778146d0fe1623904e57b9188e5" title="Returns the number of code units in this string. ">size()</a> &lt;= <a class="el" href="struct_utf_string_1_1_utf8_string.html#ae5ff9e9f4644060a75d195cb3f2b1b4a" title="Returns the largest number of code units that can be stored in this string without increasing the mem...">capacity()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of code units this string can hold before needing to allocation more memory </dd></dl>

</div>
</div>
<a class="anchor" id="a4a0bb93367a5dd328ba80924e50fe77b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t UtfString::Utf8String::CharacterCodeUnitCount </td>
          <td>(</td>
          <td class="paramtype">const std::string::const_iterator&#160;</td>
          <td class="paramname"><em>stringIterator</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of code units in the character that the string iterator is pointing to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stringIterator</td><td>An iterator pointing to a character on a string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2ed159b5072bc40e77ae5fad0911979"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t UtfString::Utf8String::CharacterCodeUnitCount </td>
          <td>(</td>
          <td class="paramtype">const std::string::const_reverse_iterator &amp;&#160;</td>
          <td class="paramname"><em>stringIterator</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of code units in the character that the string reverse iterator is pointing to. </p>
<p>If the reverse iterator is pointing to a code unit that is not the last code unit, a 0 is returned.</p>
<p>Note that since this function deals with a reverse iterator, it is expecting the code units to be in the reverse order, meaning that the second code unit is expected to come before the first code unit, the third code unit is expected to come before the second code unit, etc. So when passing an iterator pointing to a multi-code-unit character, make sure that the iterator is pointing at the very last code unit, and not the first as expected by the overload of this function that accepts a forward iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stringIterator</td><td>A reverse iterator pointing to a character in a string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of code units in the character that the string reverse iterator is pointing to, or 0 if the reverse iterator is pointing to a code unit that is not the last code unit </dd></dl>

</div>
</div>
<a class="anchor" id="ae20c7e3e5c9144ac17cc34b8914abc46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t UtfString::Utf8String::CharacterCodeUnitCount </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>characterPointer</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts the number of code units in the character that a character pointer is pointing to. </p>
<p>This function assumes that characterPointer is a valid pointer and is pointing to the first code unit of a UTF-8 code point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">characterPointer</td><td>A pointer pointing to the first code unit of a UTF-8 code point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a758325e87dfd96fac84945e5266861c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::Utf8String::code_point_index </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>codeUnitIndex</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the index of a code unit to the index of the corresponding code point. </p>
<p>The code point index is the index used in this string to identify a particular code point. The code unit index is the index used in the underlying code unit string to identify a particular code unit.</p>
<p>It does not matter whether the code unit index is the first code unit in the code point or not. As long as the string is valid, this function will be able to find the corresponding code point for any code unit.</p>
<p>This function assumes <a class="el" href="struct_utf_string_1_1_utf8_string.html#a8427b3c37edfdba9b3981ff401d5a384" title="Indicates whether the code units in this string comprise a valid UTF-8 string. ">is_valid()</a> is true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codeUnitIndex</td><td>The index of the code unit whose corresponding code point is to be found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the corresponding code point </dd></dl>

</div>
</div>
<a class="anchor" id="ac1eaa9f2a819c165840ae7b670c02f8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::Utf8String::code_unit_index </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>codePointIndex</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the index of a code point to the index of that code point's first code unit. </p>
<p>The code point index is the index used in this string to identify a particular code point. The code unit index is the index used in the underlying code unit string to identify a particular code unit.</p>
<p>This function assumes <a class="el" href="struct_utf_string_1_1_utf8_string.html#a8427b3c37edfdba9b3981ff401d5a384" title="Indicates whether the code units in this string comprise a valid UTF-8 string. ">is_valid()</a> is true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codePointIndex</td><td>The index of the code point whose code units are to be found</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first code unit of the code point </dd></dl>

</div>
</div>
<a class="anchor" id="afe5038bfa65448466698eb06d6a82355"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UtfString::Utf8String::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other. </p>
<p>If this string is the same as the parameter string, then the two strings are considered equal. If the strings are different, then one is considered to be less than the other. The strings are compared "alphabetically", and placed in "alphabetical" order. The string that comes before the other string in that order is considered to be less than higher-ordered other string.</p>
<p>Note that "alphabetical" order is used in quotations because it isn't truly alphabetical. Different languages have different symbols and may have complex rules for the ordering of characters. This class does not attempt to address those issues, but instead compares code points based on their Unicode value. So any particular Latin code point will be considered to be less than any particular Cyrillic code point, because the Cyrillic code points have higher Unicode values. Within the English language, the code points are numbered so that they will be compared according to the rules of the language. This may or may not be the case for code points used by other languages.</p>
<p>If language- or locale-specific comparison is necessary, it would be better to use the <a href="http://www.icu-project.org/">ICU</a> library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>A string to be compared to this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative number if this string is less than the parameter string, a zero if this string is equal to the parameter string, and a positive number if this string is greater than the parameter string </dd></dl>

</div>
</div>
<a class="anchor" id="ac42c364d4afbfa4ada3ff385be5227be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UtfString::Utf8String::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other. </p>
<p>If this string is the same as the parameter string, then the two strings are considered equal. If the strings are different, then one is considered to be less than the other. The strings are compared "alphabetically", and placed in "alphabetical" order. The string that comes before the other string in that order is considered to be less than higher-ordered other string.</p>
<p>Note that "alphabetical" order is used in quotations because it isn't truly alphabetical. Different languages have different symbols and may have complex rules for the ordering of characters. This class does not attempt to address those issues, but instead compares code points based on their Unicode value. So any particular Latin code point will be considered to be less than any particular Cyrillic code point, because the Cyrillic code points have higher Unicode values. Within the English language, the code points are numbered so that they will be compared according to the rules of the language. This may or may not be the case for code points used by other languages.</p>
<p>If language- or locale-specific comparison is necessary, it would be better to use the <a href="http://www.icu-project.org/">ICU</a> library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string to be compared to this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative number if this string is less than the parameter string, a zero if this string is equal to the parameter string, and a positive number if this string is greater than the parameter string </dd></dl>

</div>
</div>
<a class="anchor" id="a64781029f89bbe02c35a8101e9e2144f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UtfString::Utf8String::compare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other. </p>
<p>If this string is the same as the parameter string, then the two strings are considered equal. If the strings are different, then one is considered to be less than the other. The strings are compared "alphabetically", and placed in "alphabetical" order. The string that comes before the other string in that order is considered to be less than higher-ordered other string.</p>
<p>Note that "alphabetical" order is used in quotations because it isn't truly alphabetical. Different languages have different symbols and may have complex rules for the ordering of characters. This class does not attempt to address those issues, but instead compares code points based on their Unicode value. So any particular Latin code point will be considered to be less than any particular Cyrillic code point, because the Cyrillic code points have higher Unicode values. Within the English language, the code points are numbered so that they will be compared according to the rules of the language. This may or may not be the case for code points used by other languages.</p>
<p>If language- or locale-specific comparison is necessary, it would be better to use the <a href="http://www.icu-project.org/">ICU</a> library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string to be compared to this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative number if this string is less than the parameter string, a zero if this string is equal to the parameter string, and a positive number if this string is greater than the parameter string </dd></dl>

</div>
</div>
<a class="anchor" id="a6789f9f61eac12dbdcc207c8ea8d2f1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UtfString::Utf8String::compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other. </p>
<p>If this string is the same as the parameter string, then the two strings are considered equal. If the strings are different, then one is considered to be less than the other. The strings are compared "alphabetically", and placed in "alphabetical" order. The string that comes before the other string in that order is considered to be less than higher-ordered other string.</p>
<p>Note that "alphabetical" order is used in quotations because it isn't truly alphabetical. Different languages have different symbols and may have complex rules for the ordering of characters. This class does not attempt to address those issues, but instead compares code points based on their Unicode value. So any particular Latin code point will be considered to be less than any particular Cyrillic code point, because the Cyrillic code points have higher Unicode values. Within the English language, the code points are numbered so that they will be compared according to the rules of the language. This may or may not be the case for code points used by other languages.</p>
<p>If language- or locale-specific comparison is necessary, it would be better to use the <a href="http://www.icu-project.org/">ICU</a> library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string to be compared to this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative number if this string is less than the parameter string, a zero if this string is equal to the parameter string, and a positive number if this string is greater than the parameter string </dd></dl>

</div>
</div>
<a class="anchor" id="affbb7f928c6297cf64538e74da5f41a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UtfString::Utf8String::compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8String</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>codeUnitCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other. </p>
<p>If this string is the same as the parameter string, then the two strings are considered equal. If the strings are different, then one is considered to be less than the other. The strings are compared "alphabetically", and placed in "alphabetical" order. The string that comes before the other string in that order is considered to be less than higher-ordered other string.</p>
<p>Note that "alphabetical" order is used in quotations because it isn't truly alphabetical. Different languages have different symbols and may have complex rules for the ordering of characters. This class does not attempt to address those issues, but instead compares code points based on their Unicode value. So any particular Latin code point will be considered to be less than any particular Cyrillic code point, because the Cyrillic code points have higher Unicode values. Within the English language, the code points are numbered so that they will be compared according to the rules of the language. This may or may not be the case for code points used by other languages.</p>
<p>If language- or locale-specific comparison is necessary, it would be better to use the <a href="http://www.icu-project.org/">ICU</a> library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string to be compared to this string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">codeUnitCount</td><td>The maximum number of code units in the string to be compared</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative number if this string is less than the parameter string, a zero if this string is equal to the parameter string, and a positive number if this string is greater than the parameter string </dd></dl>

</div>
</div>
<a class="anchor" id="a2f4ee32100bba5c5daf214781f96f830"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::Utf8String::copy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>codeUnitArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>codeUnitArraySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>characterCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>characterOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies at most a specific number of code points in this string into an array of code units. </p>
<p>Although the array being copied to is an array of code units, the parameters that indicate which code points are to be copied in this string are the indexes of code points, not of code units. This string is intended to abstract the individual code units.</p>
<p>So if we copy three code points into the code unit array, as few as three or as many as six 16-bit code units will be copied to the code unit array, depending on how many code units comprise the three code points.</p>
<p>If the number of code points to be copied is such so that there isn't enough room in the code unit array for the corresponding code units, the maximum possible number of code points will be copied without going over the boundaries of the array.</p>
<p>Note that this function does not append a null terminator at the end of the array being copied to.</p>
<p>This function assumes that codeUnitArray points to a valid array and that characterOffset &lt; <a class="el" href="struct_utf_string_1_1_utf8_string.html#a518584516f646c27f1b3abead0923930" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codeUnitArray</td><td>An array of 8-bit code units that will contain the copied code points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">codeUnitArraySize</td><td>The size of the code unit array to be copied to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">characterCount</td><td>The maximum number of code points to be copied to the code unit array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">characterOffset</td><td>The code point offset in this string where the copying to to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of code units that were actually copied </dd></dl>

</div>
</div>
<a class="anchor" id="afc768fd81bbcff6e3466610918d1d3f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* UtfString::Utf8String::data </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer an array of 8-bit code units containing the contents of this string. </p>
<p>This array is owned by this object, and the pointer returned by this function is invalidated if any non-const functions are called on this object.</p>
<p>This function is almost the same as the <a class="el" href="struct_utf_string_1_1_utf8_string.html#ae08f897fb5c37039626c6f8130afa36f" title="Returns c-style version of this string as an array of 8-bit code units. ">c_str()</a> function: the only difference is that the array being returned by this function does not have a null terminator.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an array of 8-bit code units </dd></dl>

</div>
</div>
<a class="anchor" id="ad34e6c5c2e00787fe5eb656f51bb8667"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static UInt32 UtfString::Utf8String::DecodeCharacter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8Character</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes a UTF-8 character, returning the result as a 32-bit code point. </p>
<p>This function assumes that utf8Character contains a valid UTF-8 character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8Character</td><td>A series of code units representing a UTF-8 character</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit code point </dd></dl>

</div>
</div>
<a class="anchor" id="af80506a324f729d0c2004a1e63ac5499"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static UInt32 UtfString::Utf8String::DecodeCharacter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>characterPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>codeUnitCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes a UTF-8 character, returning the result as a 32-bit code point. </p>
<p>This function assumes that characterPointer points to a buffer containing a valid UTF-8 character. The length of the buffer must be between 1 and 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">characterPointer</td><td>A pointer to a buffer containing a series of UTF-8 code units representing a UTF-8 character </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">codeUnitCount</td><td>The length of the buffer pointed to by characterPointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32-bit code point </dd></dl>

</div>
</div>
<a class="anchor" id="a97b16ea36e810f7aeb61e7b63ac00aa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::Utf8String::empty </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether this string is empty. </p>
<p>If it should be the case that there are code units in the string but no valid code points, the string will be considered non-empty, and false will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>true if there are no characters in this string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="abfc70110c13c512171130d0db33fdc6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> UtfString::Utf8String::EncodeCharacter </td>
          <td>(</td>
          <td class="paramtype">const UInt32&#160;</td>
          <td class="paramname"><em>codePoint</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes a 32-bit code point as a UTF-8 character. </p>
<p>This function assumes that codePoint falls in the valid Unicode character range of 000000-10FFFF.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codePoint</td><td>A 32-bit code point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A UTF-8 character corresponding to the given code point </dd></dl>

</div>
</div>
<a class="anchor" id="ac63b4fae695581535f96725f03003e01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">iterator</a> UtfString::Utf8String::end </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the location succeeding the last character in a string. </p>
<p>The iterator returned by this function is usually used to test whether an iterator has reached the end of a string. The iterator returned by this function should never be dereferenced, as it doesn't not point to a part of the string.</p>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional iterator pointing to the location succeeding the last character in a string </dd></dl>

</div>
</div>
<a class="anchor" id="a7e74162261a52a1ec432fc77a1dfb38d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_utf8_string_1_1const__iterator.html">const_iterator</a> UtfString::Utf8String::end </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an constant iterator pointing to the location succeeding the last character in a string. </p>
<p>The iterator returned by this function is usually used to test whether an iterator has reached the end of a string. The iterator returned by this function should never be dereferenced, as it doesn't not point to a part of the string.</p>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional constant iterator pointing to the location succeeding the last character in a string </dd></dl>

</div>
</div>
<a class="anchor" id="a4fecf169b2cf76feaefc0d3b957fc4a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a> UtfString::Utf8String::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>firstPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>lastPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a range of characters from this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstPosition</td><td>An iterator pointing to the first character of the range to be removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lastPosition</td><td>An iterator pointing to the position one past the last character of the range to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first character after the range of characters that were removed </dd></dl>

</div>
</div>
<a class="anchor" id="aae7452379795bf8897add1030f7ae200"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a> UtfString::Utf8String::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a character from this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>An iterator pointing to the character to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first character after character that was removed </dd></dl>

</div>
</div>
<a class="anchor" id="a2c1fdc97a5528f54dc3eb4ee2dae298f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::erase </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code><a class="el" href="struct_utf_string_1_1_utf8_string.html#ab6360100853a5b548ec1801fb1f435ae">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a range of characters from this string. </p>
<p>This function will only cause characters to be removed up to the end of the string, so an overly large count parameter value will not cause problems.</p>
<p>This function assumes that offset &lt;= <a class="el" href="struct_utf_string_1_1_utf8_string.html#a518584516f646c27f1b3abead0923930" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset describing the index location of the first character to be removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The maximum number of characters to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the specified range of characters have been removed </dd></dl>

</div>
</div>
<a class="anchor" id="aea28feab6aa3406e0b2bb133472d3cbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::Utf8String::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for specific substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The substring to be found in this string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index at which the substring was found, or npos if the substring was not found </dd></dl>

</div>
</div>
<a class="anchor" id="a4ee278d89decd987ea95067f3bbb88b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::Utf8String::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the first character that is not found in a given string. </p>
<p>Note that if searchString is not a valid UTF-8 string, this function will still work, but the result may turn up an unexpected code point. For example, if the search string contains only the second code unit of a two-code-unit code point, that code point in the string being searched may still be the character identified by the search result, because even though the second code unit was in the search string, the first code unit of that code point was not. This is because there are numerous code points that could have that second code unit, and there is no way to distinguish between them if we are only given one code unit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be excluded in the search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character in this string that is not a character in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="ad3f4018ceaa79c356b926f803ed40ca8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::Utf8String::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the first character that is found in a given string. </p>
<p>This function differes from <a class="el" href="struct_utf_string_1_1_utf8_string.html#aea28feab6aa3406e0b2bb133472d3cbb" title="Searches this string for specific substring. ">find()</a> in that <a class="el" href="struct_utf_string_1_1_utf8_string.html#aea28feab6aa3406e0b2bb133472d3cbb" title="Searches this string for specific substring. ">find()</a> searches for the exact occurrance of the search string whereas this function searches for any one of the characters found in the search string.</p>
<p>This function assumes <a class="el" href="struct_utf_string_1_1_utf8_string.html#a8427b3c37edfdba9b3981ff401d5a384" title="Indicates whether the code units in this string comprise a valid UTF-8 string. ">is_valid()</a> is true and searchString.is_valid() is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be searched for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character in this string that is also in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="ae6482960ae19d0f5c119369daf3a21f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::Utf8String::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="struct_utf_string_1_1_utf8_string.html#ab6360100853a5b548ec1801fb1f435ae">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the last character that is not found in a given string. </p>
<p>Note that if searchString is not a valid UTF-8 string, this function will still work, but the result may turn up an unexpected code point. For example, if the search string contains only the second code unit of a two-code-unit code point, that code point in the string being searched may still be the character identified by the search result, because even though the second code unit was in the search string, the first code unit of that code point was not. This is because there are numerous code points that could have that second code unit, and there is no way to distinguish between them if we are only given one code unit.</p>
<p>Please note that the offset in this function controls the index where the search <em>ends</em>, and not where it begins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be excluded in the search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to finish</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last character in this string that is not a character in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="af3ca9a0e754196d1ff8c3bdd4e4d1e70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::Utf8String::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="struct_utf_string_1_1_utf8_string.html#ab6360100853a5b548ec1801fb1f435ae">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the last character that is found in a given string. </p>
<p>This function differes from <a class="el" href="struct_utf_string_1_1_utf8_string.html#aea28feab6aa3406e0b2bb133472d3cbb" title="Searches this string for specific substring. ">find()</a> in that <a class="el" href="struct_utf_string_1_1_utf8_string.html#aea28feab6aa3406e0b2bb133472d3cbb" title="Searches this string for specific substring. ">find()</a> searches for the exact occurrance of the search string whereas this function searches for any one of the characters found in the search string.</p>
<p>Please note that the offset in this function controls the index where the search <em>ends</em>, and not where it begins.</p>
<p>This function assumes <a class="el" href="struct_utf_string_1_1_utf8_string.html#a8427b3c37edfdba9b3981ff401d5a384" title="Indicates whether the code units in this string comprise a valid UTF-8 string. ">is_valid()</a> is true and searchString.is_valid() is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be searched for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to finish</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last character in this string that is also in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="a922265c008dce096bd3d601cdf5442ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::insert </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the contents of another string into this string at a specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index in this string where the parameter string is to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>A string of 16-bit code units to be appended</td></tr>
  </table>
  </dd>
</dl>
<p>Note that text can be inserted at the end of the string by specifying an index one past the end of the string.</p>
<p>This function assumes index &lt;= <a class="el" href="struct_utf_string_1_1_utf8_string.html#a518584516f646c27f1b3abead0923930" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a9c288039647bb6e9743f8701f97cc558"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::insert </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the contents of another string into this string at a specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index in this string where the parameter string is to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A UTF-8 string to be appended. The string is assumed to be a valid UTF-8 string.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that text can be inserted at the end of the string by specifying an index one past the end of the string.</p>
<p>This function assumes index &lt;= <a class="el" href="struct_utf_string_1_1_utf8_string.html#a518584516f646c27f1b3abead0923930" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a587c270802c8e143fdf3728f0265dcf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::insert </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the contents of another string into this string at a specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index in this string where the parameter string is to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A UTF-8 string to be appended. The string is assumed to be a valid UTF-8 string.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that text can be inserted at the end of the string by specifying an index one past the end of the string.</p>
<p>This function assumes index &lt;= <a class="el" href="struct_utf_string_1_1_utf8_string.html#a518584516f646c27f1b3abead0923930" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a2bbb7a410ecf77c75aa8f409bf642556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::insert </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8String</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the contents of another string into this string at a specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index in this string where the parameter string is to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A UTF-8 string to be appended. The string is assumed to be a valid UTF-8 string.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that text can be inserted at the end of the string by specifying an index one past the end of the string.</p>
<p>This function assumes index &lt;= <a class="el" href="struct_utf_string_1_1_utf8_string.html#a518584516f646c27f1b3abead0923930" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a2d97ce4ad6a27d4205ae27ecd8b02b3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::insert </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8String</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>codeUnitCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the contents of another string into this string at a specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index in this string where the parameter string is to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A UTF-8 string to be appended. The string is assumed to be a valid UTF-8 string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">codeUnitCount</td><td>The number of code units in utf8String to be appended</td></tr>
  </table>
  </dd>
</dl>
<p>Note that text can be inserted at the end of the string by specifying an index one past the end of the string.</p>
<p>This function assumes index &lt;= <a class="el" href="struct_utf_string_1_1_utf8_string.html#a518584516f646c27f1b3abead0923930" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="ab8d5e8d009d929ce320219004eaed2fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::insert </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8Character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a character into this string at a specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index in this string where the character is to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8Character</td><td>A UTF-8 character to be appended. The character is assumed to be a valid UTF-8 character</td></tr>
  </table>
  </dd>
</dl>
<p>Note that the cahracter can be inserted at the end of the string by specifying an index one past the end of the string.</p>
<p>This function assumes utf8Character is a valid character and that index &lt;= <a class="el" href="struct_utf_string_1_1_utf8_string.html#a518584516f646c27f1b3abead0923930" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a8427b3c37edfdba9b3981ff401d5a384"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::Utf8String::is_valid </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether the code units in this string comprise a valid UTF-8 string. </p>
<dl class="section return"><dt>Returns</dt><dd>true if this string is a valid UTF-8 string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a996e22f5c05348d18b3856b8bb449461"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool UtfString::Utf8String::IsValidCharacter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8Character</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether a series of 8-bit code units is a valid UTF-8 character. </p>
<p>One-code-unit characters are valid if the most significant bit is 0. Two-code-unit characters are valid if the first code unit starts with 110, the second code unit starts with 10, and the encoded code point is in the range 000080-0007FF. Three-code-unit characters are valid if the first code unit starts with 1110, the second and third code units start with 10, and the encoded code point is in the range 000800-00FFFF. Four-code-unit characters are valid if the first code unit starts with 11110, the second, third, and fourth code units start with 10, the encoded code point is in the range 010000-10FFFF, and the encoded code point is not one of the 32 non-characters specified by the UTF-8 specification.</p>
<p>The 32 non-character code points are 1FFF*, 2FFF*, ..., 10FFF*, where * is an E or an F.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8Character</td><td>A series of 8-bit code units to be validated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the series of code units represents a valid UTF-8 character, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="ab0bcc7a338352c15400353f3ab66a647"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool UtfString::Utf8String::IsValidCharacter </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>characterPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>codeUnitCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether a series of 8-bit code units is a valid UTF-8 character. </p>
<p>One-code-unit characters are valid if the most significant bit is 0. Two-code-unit characters are valid if the first code unit starts with 110, the second code unit starts with 10, and the encoded code point is in the range 000080-0007FF. Three-code-unit characters are valid if the first code unit starts with 1110, the second and third code units start with 10, and the encoded code point is in the range 000800-00FFFF. Four-code-unit characters are valid if the first code unit starts with 11110, the second, third, and fourth code units start with 10, the encoded code point is in the range 010000-10FFFF, and the encoded code point is not one of the 32 non-characters specified by the UTF-8 specification.</p>
<p>The 32 non-character code points are 1FFF*, 2FFF*, ..., 10FFF*, where * is an E or an F.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">characterPointer</td><td>A pointer to the buffer containing the series of 8-bit code units </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">codeUnitCount</td><td>The number of code units in the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the series of code units represents a valid UTF-8 character, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a5e36ba72528de7079e560936857cefcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool UtfString::Utf8String::IsWhitespace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>utf8Character</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>codeUnitCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether a UTF-8 character is a whitespace character. </p>
<p>This function tests for the standard ASCII whitespace characters(tab, space, carriage return, line feed), and the characters that the Unicode standard defines as being separator characters.</p>
<p>This function assumes that codeUnitCount &lt;= 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8Character</td><td>A pointer to the first code unit of the code point to be examined </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">codeUnitCount</td><td>The number of code units in the code point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If utf8Character is a whitespace character, true, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="aec0641f10d0bec2bfe21fd5d02038f2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool UtfString::Utf8String::IsWhitespace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8Character</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether a UTF-8 character is a whitespace character. </p>
<p>This function tests for the standard ASCII whitespace characters(tab, space, carriage return, line feed), and the characters that the Unicode standard defines as being separator characters.</p>
<p>This function assumes that utf8Character.size() &lt;= 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8Character</td><td>A <a class="el" href="class_utf_string_1_1_utf8_char.html" title="Provides a copy of a UTF-8 character embedded in a UTF-8 string. ">Utf8Char</a> object containing the code point to be examined</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If utf8Character is a whitespace character, true, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a518584516f646c27f1b3abead0923930"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::Utf8String::length </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of code points in this string. </p>
<p>Use this function if you're interested in how many characters are in a string. If you're interested in the number of code units (which may be different if any code points consist of multiple code units), then use the <a class="el" href="struct_utf_string_1_1_utf8_string.html#a4cda0778146d0fe1623904e57b9188e5" title="Returns the number of code units in this string. ">size()</a> function.</p>
<p>This function does not check for validity, so it may return an incorrect result if the code units comprising this string do not form a valid UTF-8 string.</p>
<p>This function has a O(N) performance, since we need to iterate through the code units to figure out how many code points there are. Counting each code point is an extremely quick operation, but due to the need to visit every code point in the string, it would be wise to be mindful of performance when making heavy use of this function on long strings in performance-sensitive code. </p>

</div>
</div>
<a class="anchor" id="af9e1bd5744d98272854fe30eb8894b7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::Utf8String::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>otherString</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of another string and tests whether the two strings are the different. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherString</td><td>The string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two strings are different, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a8c61cb8870265b214449fed9e3620a33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::Utf8String::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>otherString</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of another string and tests whether the value of this string is less than the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherString</td><td>The string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is less than the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="ab324833151cb5ac0e622764196095180"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::Utf8String::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>otherString</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of another string and tests whether the value of this string is less than or equal to the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherString</td><td>The string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is less than or equal to the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a396d76ea0929c8b06c6954f028675114"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::Utf8String::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>otherString</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of another string and tests whether the two strings are the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherString</td><td>The string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two strings are the same, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="ac9899daa4d9093285d21c3adad5476b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::Utf8String::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>otherString</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of another string and tests whether the value of this string is greater than the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherString</td><td>The string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is greater than the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a6677b1c67bf291781ae07c565e357724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::Utf8String::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>otherString</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of another string and tests whether the value of this string is greater than or equal to the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherString</td><td>The string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is greater than or equal to the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a3a8698fcbb8b88f7a7a97e67c146d660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_utf8_char_reference.html">Utf8CharReference</a> UtfString::Utf8String::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the character found at the specified character index. </p>
<p>This operator does not check for the validity of the index, so it assumes that index is valid. What happens when the index is invalid is undefined. If you want the index parameter to be validated, use the <a class="el" href="struct_utf_string_1_1_utf8_string.html#aa2bf3a2a99adab53783b25952f4511b1" title="Returns a reference to the character found at the specified character index. ">at()</a> function instead.</p>
<p>Note that unlike standard ASCII or UCS-2, which are fixed-length encodings, UTF-8 is a variable length encoding. This means that whereas accessing a character at a particular index is O(1) for fixed-length encodings, accessing a character in UTF-8 strings is O(1) in the best case and O(n) in the worst case.</p>
<p>So if you wish to iterate through the characters in this string, use the standard iterators instead of an indexer. The standard iterators will be far more efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index identifying the character to be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character found at the specified index </dd></dl>

</div>
</div>
<a class="anchor" id="afad04c2f625775e0a5afa3ba9ff50fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> UtfString::Utf8String::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the character found at the specified character index. </p>
<p>This operator does not check for the validity of the index, so it assumes that index is valid. What happens when the index is invalid is undefined. If you want the index parameter to be validated, use the <a class="el" href="struct_utf_string_1_1_utf8_string.html#aa2bf3a2a99adab53783b25952f4511b1" title="Returns a reference to the character found at the specified character index. ">at()</a> function instead.</p>
<p>Note that unlike standard ASCII or UCS-2, which are fixed-length encodings, UTF-8 is a variable length encoding. This means that whereas accessing a character at a particular index is O(1) for fixed-length encodings, accessing a character in UTF-8 strings is O(1) in the best case and O(n) in the worst case.</p>
<p>So if you wish to iterate through the characters in this string, use the standard iterators instead of an indexer. The standard iterators will be far more efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index identifying the character to be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character found at the specified index </dd></dl>

</div>
</div>
<a class="anchor" id="a294cde176dd9e86277839671800ee5ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UtfString::Utf8String::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;&#160;</td>
          <td class="paramname"><em>character</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a character to the end of this string. </p>
<p>This function is the equivalent of calling insert(<a class="el" href="struct_utf_string_1_1_utf8_string.html#a518584516f646c27f1b3abead0923930" title="Returns the number of code points in this string. ">length()</a>, character) or append(character).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">character</td><td>The character to be appended to the end of this string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b8fc579435d2a12db6a8e3b4af1f648"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_utf8_string_1_1reverse__iterator.html">reverse_iterator</a> UtfString::Utf8String::rbegin </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first character of a reversed string, which corresponds to the last character of the normal string. </p>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional iterator pointing to the first character in a reversed string or just beyond the end of an empty reversed string </dd></dl>

</div>
</div>
<a class="anchor" id="a018a66e6b3d0192935f82453cee55269"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_utf8_string_1_1const__reverse__iterator.html">const_reverse_iterator</a> UtfString::Utf8String::rbegin </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the first character of a reversed string, which corresponds to the last character of a normal string. </p>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional constant iterator pointing to the first character in a reversed string or just beyond the end of an empty reversed string </dd></dl>

</div>
</div>
<a class="anchor" id="a27adb94911202726b7bb239aed6918c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_utf8_string_1_1reverse__iterator.html">reverse_iterator</a> UtfString::Utf8String::rend </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the location succeeding the last character in a reversed string, which corresponds to the location preceding the first character in a normal string. </p>
<p>The iterator returned by this function is usually used to test whether an iterator has reached the end of a string. The iterator returned by this function should never be dereferenced, as it doesn't not point to a part of the string.</p>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional iterator pointing to the location succeeding the last character in a reversed string </dd></dl>

</div>
</div>
<a class="anchor" id="aa1d453a90ce2e37f486e2359f0fc352c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_utf8_string_1_1const__reverse__iterator.html">const_reverse_iterator</a> UtfString::Utf8String::rend </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an constant iterator pointing to the location succeeding the last character in a reversed string, which corresponds to the location preceding the first character in a normal string. </p>
<p>The iterator returned by this function is usually used to test whether an iterator has reached the end of a string. The iterator returned by this function should never be dereferenced, as it doesn't not point to a part of the string.</p>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional constant iterator pointing to the location succeeding the last character in a reversed string </dd></dl>

</div>
</div>
<a class="anchor" id="a1457d47462c3281ba7abfae9d5c8e824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::replace </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>replacementString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a section of this string and replaces it with the contents of another string. </p>
<p>Note that if position is one index past the end of the string, replacementString will simply be appended to the end of the string.</p>
<p>This function assumes position &lt;= <a class="el" href="struct_utf_string_1_1_utf8_string.html#a518584516f646c27f1b3abead0923930" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The index in the string identifying the beginning of the string section to be removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The maximum number of characters to be removed from this string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacementString</td><td>The string whose contents are to replace the section being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the replacement has been completed </dd></dl>

</div>
</div>
<a class="anchor" id="afaf7e554fe572752b1333df55a0a09a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::replace </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>characterCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the characters in a section of this string with the given character. </p>
<p>This function assumes position &lt;= <a class="el" href="struct_utf_string_1_1_utf8_string.html#a518584516f646c27f1b3abead0923930" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The index in the string identifying the first character to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The maximum number of characters to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">characterCount</td><td>The number of times the character is to be repeated in the replaced section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">character</td><td>The character to replace the characters in the identified section of this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the replacement has been completed </dd></dl>

</div>
</div>
<a class="anchor" id="a0754934a75b663056a35ea5df110144c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a>&#160;</td>
          <td class="paramname"><em>beginIterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a>&#160;</td>
          <td class="paramname"><em>endIterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>replacementString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a section of this string and replaces it with the contents of another string. </p>
<p>This function replaces the section of the string from beginIterator to endIterator - 1, where endIterator is pointing at a position one past the end of the section to be replaced.</p>
<p>If endIterator points to a position before beginIterator, endIterator is ignored and the entire string from beginIterator to the end of the string is replaced. If beginIterator points to the same position as endIterator, replacementString is simply inserted at that position and nothing in this string is removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beginIterator</td><td>An iterator pointing to the first character of the string section to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endIterator</td><td>An iterator pointing to the position one past the last character of the string section to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacementString</td><td>The string whose contents are to replace the section being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the replacement has been completed </dd></dl>

</div>
</div>
<a class="anchor" id="a89b8f5db00982fc92ed6496f9423c9da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a>&amp; UtfString::Utf8String::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a>&#160;</td>
          <td class="paramname"><em>beginIterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_utf_string_1_1_utf8_string_1_1iterator.html">Utf8String::iterator</a>&#160;</td>
          <td class="paramname"><em>endIterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>characterCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_utf8_char.html">Utf8Char</a> &amp;&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the characters in a section of this string with the given character. </p>
<p>This function replaces the section of the string from beginIterator to endIterator - 1, where endIterator is pointing at a position one past the end of the section to be replaced.</p>
<p>If endIterator points to a position before beginIterator, endIterator is ignored and the entire string from beginIterator to the end of the string is replaced. If beginIterator points to the same position as endIterator, the new characters are simply inserted at that position and nothing in this string is removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beginIterator</td><td>An iterator pointing to the first character of the string section to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endIterator</td><td>An iterator pointing to the position one past the last character of the string section to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">characterCount</td><td>The number of times the character is to be repeated in the replaced section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">character</td><td>The character to replace the characters in the identified section of this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the replacement has been completed </dd></dl>

</div>
</div>
<a class="anchor" id="a77ba6243cff966e290d56e3034483dea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::Utf8String::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="struct_utf_string_1_1_utf8_string.html#ab6360100853a5b548ec1801fb1f435ae">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string backward for specific substring. </p>
<p>Note this does not look at the characters in reverse order like iterating through a string with a reverse iterator. It looks at the characters in forward order just like the <a class="el" href="struct_utf_string_1_1_utf8_string.html#aea28feab6aa3406e0b2bb133472d3cbb" title="Searches this string for specific substring. ">find()</a> function, but starts at the end of the string and works backward toward the beginning.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The substring to be found in this string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index at which the substring was found, or npos if the substring was not found </dd></dl>

</div>
</div>
<a class="anchor" id="a4cda0778146d0fe1623904e57b9188e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::Utf8String::size </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of code units in this string. </p>
<p>If you are interested in how many characters are in this string, use the <a class="el" href="struct_utf_string_1_1_utf8_string.html#a518584516f646c27f1b3abead0923930" title="Returns the number of code points in this string. ">length()</a> function instead.</p>
<p>Most likely this function has a O(1) performance, since it is a simple count of the number of elements a string. However, this depends on the implementation of the underlying STL string::size() function. </p>

</div>
</div>
<a class="anchor" id="a0b32a8159e4800d99e0c14fc028bf073"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> UtfString::Utf8String::substr </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code><a class="el" href="struct_utf_string_1_1_utf8_string.html#ab6360100853a5b548ec1801fb1f435ae">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a substring of this string. </p>
<p>The offset parameter indicates which character in the string will become the first character of the substring and the count parameter indicates how many characters will be copied into the substring. If the value of count would cause characters beyond the end of this string to be copied, only characters from the offset to the end of the string will be copied.</p>
<p>This function assumes that offset &lt; <a class="el" href="struct_utf_string_1_1_utf8_string.html#a518584516f646c27f1b3abead0923930" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The string offset indicating the first character of the substring </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of characters to be copied into the substring</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A substring as describe by the parameters </dd></dl>

</div>
</div>
<a class="anchor" id="ab49b591a7db63b8d8f5a3dd1a7c30269"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UtfString::Utf8String::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this string with those of another string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>The string whose contents are to be swapped with the contents this string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="acfdf11dff1931b8000b35967714b53bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator converts a UTF-8 string to a stream of 8-bit values. </p>
<p>No checks for validity are done, so the resulting UTF-8 stream may or may contain a valid UTF-8 string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outputStream</td><td>The output stream to which the contents of the UTF-8 string are to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>The UTF-8 string to be written to the output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50c42b5ce8de9eb5c9d2635b76fb01f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>inputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator converts a stream of 8-bit values to a UTF-8 string. </p>
<p>This function clears the contents of utf8String before the stream is converted. In addition this function assumes that the stream being converted is of the same endianness as the machine on which this function was compiled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputStream</td><td>The input stream containing 8-bit values to be converted to a UTF-8 string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>The string object into which the converted UTF-8 string will be stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>C:/Development/Libraries/UtfString/include/utfstring/Utf8String.h</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jun 22 2013 21:27:24 for UtfString by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
