<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>UtfString: UtfString::UnicodeString Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">UtfString
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_utf_string.html">UtfString</a></li><li class="navelem"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_utf_string_1_1_unicode_string-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">UtfString::UnicodeString Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains and manages an encoding-neutral Unicode string.  
 <a href="class_utf_string_1_1_unicode_string.html#details">More...</a></p>

<p><code>#include &lt;UnicodeString.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that iterates through the code points in a Unicode string, but allowing only access to constant code points.  <a href="class_utf_string_1_1_unicode_string_1_1const__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string_1_1const__reverse__iterator.html">const_reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that iterates through the code points in a Unicode string in reverse order, but allowing only access to constant code points.  <a href="class_utf_string_1_1_unicode_string_1_1const__reverse__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that iterates through the code points in a Unicode string.  <a href="class_utf_string_1_1_unicode_string_1_1iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator that iterates through the code points in a Unicode string in reverse order.  <a href="class_utf_string_1_1_unicode_string_1_1reverse__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a74a726cd0672ced4989bf530698a079f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74a726cd0672ced4989bf530698a079f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a74a726cd0672ced4989bf530698a079f">UnicodeString</a> ()</td></tr>
<tr class="memdesc:a74a726cd0672ced4989bf530698a079f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default constructor. <br/></td></tr>
<tr class="separator:a74a726cd0672ced4989bf530698a079f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9970b67ff2645828c0ba67a3ba6724"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#add9970b67ff2645828c0ba67a3ba6724">UnicodeString</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;unicodeString)</td></tr>
<tr class="memdesc:add9970b67ff2645828c0ba67a3ba6724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialized this string with another <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> object.  <a href="#add9970b67ff2645828c0ba67a3ba6724">More...</a><br/></td></tr>
<tr class="separator:add9970b67ff2645828c0ba67a3ba6724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e0801ec0038100c90493e033601fbe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#ad9e0801ec0038100c90493e033601fbe">UnicodeString</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String)</td></tr>
<tr class="memdesc:ad9e0801ec0038100c90493e033601fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes this string with a UTF-16 string.  <a href="#ad9e0801ec0038100c90493e033601fbe">More...</a><br/></td></tr>
<tr class="separator:ad9e0801ec0038100c90493e033601fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a7526d6c363369b10246f09d9a2470"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a02a7526d6c363369b10246f09d9a2470">UnicodeString</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String)</td></tr>
<tr class="memdesc:a02a7526d6c363369b10246f09d9a2470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes this string with a UTF-8 string.  <a href="#a02a7526d6c363369b10246f09d9a2470">More...</a><br/></td></tr>
<tr class="separator:a02a7526d6c363369b10246f09d9a2470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707c6075c5610cda31f8183096f3e4f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a707c6075c5610cda31f8183096f3e4f0"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a707c6075c5610cda31f8183096f3e4f0">~UnicodeString</a> ()</td></tr>
<tr class="memdesc:a707c6075c5610cda31f8183096f3e4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class destructor. <br/></td></tr>
<tr class="separator:a707c6075c5610cda31f8183096f3e4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99931f94d340e3107de2891de5f2f4e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a99931f94d340e3107de2891de5f2f4e5">append</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;unicodeString)</td></tr>
<tr class="memdesc:a99931f94d340e3107de2891de5f2f4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the contents of another string to this string.  <a href="#a99931f94d340e3107de2891de5f2f4e5">More...</a><br/></td></tr>
<tr class="separator:a99931f94d340e3107de2891de5f2f4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc249ff8a2357c7046a366bf8089e7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a5bc249ff8a2357c7046a366bf8089e7b">append</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String)</td></tr>
<tr class="memdesc:a5bc249ff8a2357c7046a366bf8089e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the contents of another string to this string.  <a href="#a5bc249ff8a2357c7046a366bf8089e7b">More...</a><br/></td></tr>
<tr class="separator:a5bc249ff8a2357c7046a366bf8089e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef517ab69b9251fd974ba8aff15ec58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#afef517ab69b9251fd974ba8aff15ec58">append</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String)</td></tr>
<tr class="memdesc:afef517ab69b9251fd974ba8aff15ec58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the contents of another string to this string.  <a href="#afef517ab69b9251fd974ba8aff15ec58">More...</a><br/></td></tr>
<tr class="separator:afef517ab69b9251fd974ba8aff15ec58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8668e99942dba46afbd0e631490b64af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a8668e99942dba46afbd0e631490b64af">append</a> (const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> &amp;unicodeCharacter)</td></tr>
<tr class="memdesc:a8668e99942dba46afbd0e631490b64af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a Unicode character to this string.  <a href="#a8668e99942dba46afbd0e631490b64af">More...</a><br/></td></tr>
<tr class="separator:a8668e99942dba46afbd0e631490b64af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30ec0511d49d208a49f621b2702bc8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#af30ec0511d49d208a49f621b2702bc8a">append</a> (const <a class="el" href="class_utf_string_1_1_unicode_char_reference.html">UnicodeCharReference</a> &amp;unicodeCharacterReference)</td></tr>
<tr class="memdesc:af30ec0511d49d208a49f621b2702bc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a Unicode character to this string.  <a href="#af30ec0511d49d208a49f621b2702bc8a">More...</a><br/></td></tr>
<tr class="separator:af30ec0511d49d208a49f621b2702bc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7edd215940479879f32db90773ffbe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#aa7edd215940479879f32db90773ffbe5">assign</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;unicodeString)</td></tr>
<tr class="memdesc:aa7edd215940479879f32db90773ffbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of another string to this string, replacing the current contents of this string.  <a href="#aa7edd215940479879f32db90773ffbe5">More...</a><br/></td></tr>
<tr class="separator:aa7edd215940479879f32db90773ffbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb831839e00a12876273a0c53041e3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a2fb831839e00a12876273a0c53041e3d">assign</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String)</td></tr>
<tr class="memdesc:a2fb831839e00a12876273a0c53041e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of another string to this string, replacing the current contents of this string.  <a href="#a2fb831839e00a12876273a0c53041e3d">More...</a><br/></td></tr>
<tr class="separator:a2fb831839e00a12876273a0c53041e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06e305069de910e20eebdaabf94561a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#ae06e305069de910e20eebdaabf94561a">assign</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String)</td></tr>
<tr class="memdesc:ae06e305069de910e20eebdaabf94561a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of another string to this string, replacing the current contents of this string.  <a href="#ae06e305069de910e20eebdaabf94561a">More...</a><br/></td></tr>
<tr class="separator:ae06e305069de910e20eebdaabf94561a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0036026aeff0641bfaa9899965b7130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#ae0036026aeff0641bfaa9899965b7130">assign</a> (const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> &amp;unicodeCharacter)</td></tr>
<tr class="memdesc:ae0036026aeff0641bfaa9899965b7130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a Unicode character to this string.  <a href="#ae0036026aeff0641bfaa9899965b7130">More...</a><br/></td></tr>
<tr class="separator:ae0036026aeff0641bfaa9899965b7130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ba531aaf19878f43e73009ad5ffc49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a20ba531aaf19878f43e73009ad5ffc49">assign</a> (const <a class="el" href="class_utf_string_1_1_unicode_char_reference.html">UnicodeCharReference</a> &amp;unicodeCharacterReference)</td></tr>
<tr class="memdesc:a20ba531aaf19878f43e73009ad5ffc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns a Unicode character to this string.  <a href="#a20ba531aaf19878f43e73009ad5ffc49">More...</a><br/></td></tr>
<tr class="separator:a20ba531aaf19878f43e73009ad5ffc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8429e64a940c50e717c6748a47e41420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_char_reference.html">UnicodeCharReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a8429e64a940c50e717c6748a47e41420">at</a> (size_t index)</td></tr>
<tr class="memdesc:a8429e64a940c50e717c6748a47e41420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the character found at the specified character index.  <a href="#a8429e64a940c50e717c6748a47e41420">More...</a><br/></td></tr>
<tr class="separator:a8429e64a940c50e717c6748a47e41420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1916c60781c2a2a9205e7af8e948f2fc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a1916c60781c2a2a9205e7af8e948f2fc">at</a> (size_t index) const </td></tr>
<tr class="memdesc:a1916c60781c2a2a9205e7af8e948f2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the character found at the specified character index.  <a href="#a1916c60781c2a2a9205e7af8e948f2fc">More...</a><br/></td></tr>
<tr class="separator:a1916c60781c2a2a9205e7af8e948f2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab52250a56b41db3654e4944fbc75efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#aab52250a56b41db3654e4944fbc75efd">begin</a> ()</td></tr>
<tr class="memdesc:aab52250a56b41db3654e4944fbc75efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first character of a string.  <a href="#aab52250a56b41db3654e4944fbc75efd">More...</a><br/></td></tr>
<tr class="separator:aab52250a56b41db3654e4944fbc75efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0357f18a6fe0063ae565f98d7a259092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a0357f18a6fe0063ae565f98d7a259092">begin</a> () const </td></tr>
<tr class="memdesc:a0357f18a6fe0063ae565f98d7a259092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the first character of a string.  <a href="#a0357f18a6fe0063ae565f98d7a259092">More...</a><br/></td></tr>
<tr class="separator:a0357f18a6fe0063ae565f98d7a259092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e063994d00bc58a745b25de7a6c5e7e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e063994d00bc58a745b25de7a6c5e7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a7e063994d00bc58a745b25de7a6c5e7e">clear</a> ()</td></tr>
<tr class="memdesc:a7e063994d00bc58a745b25de7a6c5e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears out the string, leaving it an empty string. <br/></td></tr>
<tr class="separator:a7e063994d00bc58a745b25de7a6c5e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa106fbee8519fed07245193c559537a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#aa106fbee8519fed07245193c559537a8">compare</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;unicodeString) const </td></tr>
<tr class="memdesc:aa106fbee8519fed07245193c559537a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other.  <a href="#aa106fbee8519fed07245193c559537a8">More...</a><br/></td></tr>
<tr class="separator:aa106fbee8519fed07245193c559537a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dce9b035f1528582fd91ce7e26feda"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#ad1dce9b035f1528582fd91ce7e26feda">compare</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String) const </td></tr>
<tr class="memdesc:ad1dce9b035f1528582fd91ce7e26feda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other.  <a href="#ad1dce9b035f1528582fd91ce7e26feda">More...</a><br/></td></tr>
<tr class="separator:ad1dce9b035f1528582fd91ce7e26feda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c53b3504ab64c379818907bfae26798"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a8c53b3504ab64c379818907bfae26798">compare</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String) const </td></tr>
<tr class="memdesc:a8c53b3504ab64c379818907bfae26798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other.  <a href="#a8c53b3504ab64c379818907bfae26798">More...</a><br/></td></tr>
<tr class="separator:a8c53b3504ab64c379818907bfae26798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3627b11da000c224c56e0c77a9275f0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a">empty</a> () const </td></tr>
<tr class="memdesc:a3627b11da000c224c56e0c77a9275f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this is an empty string.  <a href="#a3627b11da000c224c56e0c77a9275f0a">More...</a><br/></td></tr>
<tr class="separator:a3627b11da000c224c56e0c77a9275f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd69f2463de9cd0f729facf9382f235e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#afd69f2463de9cd0f729facf9382f235e">end</a> ()</td></tr>
<tr class="memdesc:afd69f2463de9cd0f729facf9382f235e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the location succeeding the last character in a string.  <a href="#afd69f2463de9cd0f729facf9382f235e">More...</a><br/></td></tr>
<tr class="separator:afd69f2463de9cd0f729facf9382f235e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4857670988d37e554eeb41b37e3ab799"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a4857670988d37e554eeb41b37e3ab799">end</a> () const </td></tr>
<tr class="memdesc:a4857670988d37e554eeb41b37e3ab799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an constant iterator pointing to the location succeeding the last character in a string.  <a href="#a4857670988d37e554eeb41b37e3ab799">More...</a><br/></td></tr>
<tr class="separator:a4857670988d37e554eeb41b37e3ab799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62781e624b179f1840e6633a3b5cedf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#ad62781e624b179f1840e6633a3b5cedf">erase</a> (const <a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a> &amp;firstPosition, const <a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a> &amp;lastPosition)</td></tr>
<tr class="memdesc:ad62781e624b179f1840e6633a3b5cedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a range of characters from this string.  <a href="#ad62781e624b179f1840e6633a3b5cedf">More...</a><br/></td></tr>
<tr class="separator:ad62781e624b179f1840e6633a3b5cedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc48cc464115565a4640c5c8ee9ba14e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#afc48cc464115565a4640c5c8ee9ba14e">erase</a> (const <a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a> &amp;position)</td></tr>
<tr class="memdesc:afc48cc464115565a4640c5c8ee9ba14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a character from this string.  <a href="#afc48cc464115565a4640c5c8ee9ba14e">More...</a><br/></td></tr>
<tr class="separator:afc48cc464115565a4640c5c8ee9ba14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6452573378b8b8c329ab28b1e83b25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a7a6452573378b8b8c329ab28b1e83b25">erase</a> (const size_t offset=0, const size_t count=<a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a>)</td></tr>
<tr class="memdesc:a7a6452573378b8b8c329ab28b1e83b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a range of characters from this string.  <a href="#a7a6452573378b8b8c329ab28b1e83b25">More...</a><br/></td></tr>
<tr class="separator:a7a6452573378b8b8c329ab28b1e83b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728660484a542f07c0d95ccff4f2b617"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617">find</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;searchString, size_t offset=0)</td></tr>
<tr class="memdesc:a728660484a542f07c0d95ccff4f2b617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for specific substring.  <a href="#a728660484a542f07c0d95ccff4f2b617">More...</a><br/></td></tr>
<tr class="separator:a728660484a542f07c0d95ccff4f2b617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffd41786cbae08a92ff198ac42378bd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#afffd41786cbae08a92ff198ac42378bd">find</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;searchString, size_t offset=0)</td></tr>
<tr class="memdesc:afffd41786cbae08a92ff198ac42378bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for specific substring.  <a href="#afffd41786cbae08a92ff198ac42378bd">More...</a><br/></td></tr>
<tr class="separator:afffd41786cbae08a92ff198ac42378bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73898e445cc8ed9146c14005f65350e2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a73898e445cc8ed9146c14005f65350e2">find</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;searchString, size_t offset=0)</td></tr>
<tr class="memdesc:a73898e445cc8ed9146c14005f65350e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for specific substring.  <a href="#a73898e445cc8ed9146c14005f65350e2">More...</a><br/></td></tr>
<tr class="separator:a73898e445cc8ed9146c14005f65350e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf5d6a8f549d2641a2cfe6b1d9cc1e4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a1bf5d6a8f549d2641a2cfe6b1d9cc1e4">find_first_not_of</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;searchString, size_t offset=0)</td></tr>
<tr class="memdesc:a1bf5d6a8f549d2641a2cfe6b1d9cc1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the first character that is not found in a given string.  <a href="#a1bf5d6a8f549d2641a2cfe6b1d9cc1e4">More...</a><br/></td></tr>
<tr class="separator:a1bf5d6a8f549d2641a2cfe6b1d9cc1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a042a0dd499663bf7966c6dc8bc42d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a14a042a0dd499663bf7966c6dc8bc42d">find_first_not_of</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;searchString, size_t offset=0)</td></tr>
<tr class="memdesc:a14a042a0dd499663bf7966c6dc8bc42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the first character that is not found in a given string.  <a href="#a14a042a0dd499663bf7966c6dc8bc42d">More...</a><br/></td></tr>
<tr class="separator:a14a042a0dd499663bf7966c6dc8bc42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d6b5ead3d1c649c274451e221072da"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a57d6b5ead3d1c649c274451e221072da">find_first_not_of</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;searchString, size_t offset=0)</td></tr>
<tr class="memdesc:a57d6b5ead3d1c649c274451e221072da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the first character that is not found in a given string.  <a href="#a57d6b5ead3d1c649c274451e221072da">More...</a><br/></td></tr>
<tr class="separator:a57d6b5ead3d1c649c274451e221072da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75640399669e0165176b998a7ea82010"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a75640399669e0165176b998a7ea82010">find_first_of</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;searchString, size_t offset=0)</td></tr>
<tr class="memdesc:a75640399669e0165176b998a7ea82010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the first character that is found in a given string.  <a href="#a75640399669e0165176b998a7ea82010">More...</a><br/></td></tr>
<tr class="separator:a75640399669e0165176b998a7ea82010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cebf60e909490ce5194d998eaee2f4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a83cebf60e909490ce5194d998eaee2f4">find_first_of</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;searchString, size_t offset=0)</td></tr>
<tr class="memdesc:a83cebf60e909490ce5194d998eaee2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the first character that is found in a given string.  <a href="#a83cebf60e909490ce5194d998eaee2f4">More...</a><br/></td></tr>
<tr class="separator:a83cebf60e909490ce5194d998eaee2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b959d9e0cb0d769c2fb9b9701c7067"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a72b959d9e0cb0d769c2fb9b9701c7067">find_first_of</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;searchString, size_t offset=0)</td></tr>
<tr class="memdesc:a72b959d9e0cb0d769c2fb9b9701c7067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the first character that is found in a given string.  <a href="#a72b959d9e0cb0d769c2fb9b9701c7067">More...</a><br/></td></tr>
<tr class="separator:a72b959d9e0cb0d769c2fb9b9701c7067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0779c7d3ee935d3df937efa7b02fcab8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a0779c7d3ee935d3df937efa7b02fcab8">find_last_not_of</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;searchString, size_t offset=<a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a>)</td></tr>
<tr class="memdesc:a0779c7d3ee935d3df937efa7b02fcab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the last character that is not found in a given string.  <a href="#a0779c7d3ee935d3df937efa7b02fcab8">More...</a><br/></td></tr>
<tr class="separator:a0779c7d3ee935d3df937efa7b02fcab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1d0f0044ac65b161b6e02c6ae113ca"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a1d1d0f0044ac65b161b6e02c6ae113ca">find_last_not_of</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;searchString, size_t offset=<a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a>)</td></tr>
<tr class="memdesc:a1d1d0f0044ac65b161b6e02c6ae113ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the last character that is not found in a given string.  <a href="#a1d1d0f0044ac65b161b6e02c6ae113ca">More...</a><br/></td></tr>
<tr class="separator:a1d1d0f0044ac65b161b6e02c6ae113ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01765e8c9151c25902a408aaa69e692a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a01765e8c9151c25902a408aaa69e692a">find_last_not_of</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;searchString, size_t offset=<a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a>)</td></tr>
<tr class="memdesc:a01765e8c9151c25902a408aaa69e692a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the last character that is not found in a given string.  <a href="#a01765e8c9151c25902a408aaa69e692a">More...</a><br/></td></tr>
<tr class="separator:a01765e8c9151c25902a408aaa69e692a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd72ddfff4e3d0194b5fffca21c5028d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#afd72ddfff4e3d0194b5fffca21c5028d">find_last_of</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;searchString, size_t offset=<a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a>)</td></tr>
<tr class="memdesc:afd72ddfff4e3d0194b5fffca21c5028d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the last character that is found in a given string.  <a href="#afd72ddfff4e3d0194b5fffca21c5028d">More...</a><br/></td></tr>
<tr class="separator:afd72ddfff4e3d0194b5fffca21c5028d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b26f8359d2d380ef3ea040db5792ae9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a4b26f8359d2d380ef3ea040db5792ae9">find_last_of</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;searchString, size_t offset=<a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a>)</td></tr>
<tr class="memdesc:a4b26f8359d2d380ef3ea040db5792ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the last character that is found in a given string.  <a href="#a4b26f8359d2d380ef3ea040db5792ae9">More...</a><br/></td></tr>
<tr class="separator:a4b26f8359d2d380ef3ea040db5792ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7dd07fdc8b30357042fc1811a47903"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a6e7dd07fdc8b30357042fc1811a47903">find_last_of</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;searchString, size_t offset=<a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a>)</td></tr>
<tr class="memdesc:a6e7dd07fdc8b30357042fc1811a47903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string for the last character that is found in a given string.  <a href="#a6e7dd07fdc8b30357042fc1811a47903">More...</a><br/></td></tr>
<tr class="separator:a6e7dd07fdc8b30357042fc1811a47903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca820b8149f155e6c02fbce13b3f45a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#aca820b8149f155e6c02fbce13b3f45a3">insert</a> (const size_t index, const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;unicodeString)</td></tr>
<tr class="memdesc:aca820b8149f155e6c02fbce13b3f45a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the contents of another string into this string at a specified index.  <a href="#aca820b8149f155e6c02fbce13b3f45a3">More...</a><br/></td></tr>
<tr class="separator:aca820b8149f155e6c02fbce13b3f45a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c83ce972b4ec14e90b5b407d6d4e6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a20c83ce972b4ec14e90b5b407d6d4e6d">insert</a> (const size_t index, const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String)</td></tr>
<tr class="memdesc:a20c83ce972b4ec14e90b5b407d6d4e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the contents of another string into this string at a specified index.  <a href="#a20c83ce972b4ec14e90b5b407d6d4e6d">More...</a><br/></td></tr>
<tr class="separator:a20c83ce972b4ec14e90b5b407d6d4e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e31e7a146b50b6096d49bb2df5c4a77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a2e31e7a146b50b6096d49bb2df5c4a77">insert</a> (const size_t index, const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String)</td></tr>
<tr class="memdesc:a2e31e7a146b50b6096d49bb2df5c4a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts the contents of another string into this string at a specified index.  <a href="#a2e31e7a146b50b6096d49bb2df5c4a77">More...</a><br/></td></tr>
<tr class="separator:a2e31e7a146b50b6096d49bb2df5c4a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0762a0934a70a9dfb30521176a947010"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a0762a0934a70a9dfb30521176a947010">insert</a> (const size_t index, const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> &amp;unicodeCharacter)</td></tr>
<tr class="memdesc:a0762a0934a70a9dfb30521176a947010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a character into this string at a specified index.  <a href="#a0762a0934a70a9dfb30521176a947010">More...</a><br/></td></tr>
<tr class="separator:a0762a0934a70a9dfb30521176a947010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609ad252e64f3a3565c2a38109c08371"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371">is_valid</a> () const </td></tr>
<tr class="memdesc:a609ad252e64f3a3565c2a38109c08371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether this string is a valid Unicode string.  <a href="#a609ad252e64f3a3565c2a38109c08371">More...</a><br/></td></tr>
<tr class="separator:a609ad252e64f3a3565c2a38109c08371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b2fecfac699d42b37e849350cda68c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_utf_string.html#ae8b43f83cfd3f6aefcd2f9c65826dfbb">UtfEncoding</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a83b2fecfac699d42b37e849350cda68c">internal_encoding</a> () const </td></tr>
<tr class="memdesc:a83b2fecfac699d42b37e849350cda68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the internal encoding used by this string.  <a href="#a83b2fecfac699d42b37e849350cda68c">More...</a><br/></td></tr>
<tr class="separator:a83b2fecfac699d42b37e849350cda68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6712e63301f5b44c7248b2e8bdb21c27"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a6712e63301f5b44c7248b2e8bdb21c27">length</a> () const </td></tr>
<tr class="memdesc:a6712e63301f5b44c7248b2e8bdb21c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of code points in this string.  <a href="#a6712e63301f5b44c7248b2e8bdb21c27">More...</a><br/></td></tr>
<tr class="separator:a6712e63301f5b44c7248b2e8bdb21c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d03386f3d45da5888df789f7011041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a71d03386f3d45da5888df789f7011041">push_back</a> (const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> &amp;character)</td></tr>
<tr class="memdesc:a71d03386f3d45da5888df789f7011041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a character to the end of this string.  <a href="#a71d03386f3d45da5888df789f7011041">More...</a><br/></td></tr>
<tr class="separator:a71d03386f3d45da5888df789f7011041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b6eb98b7ba8c206526ad5fee940c89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a77b6eb98b7ba8c206526ad5fee940c89">rbegin</a> ()</td></tr>
<tr class="memdesc:a77b6eb98b7ba8c206526ad5fee940c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the first character of a reversed string, which corresponds to the last character of the normal string.  <a href="#a77b6eb98b7ba8c206526ad5fee940c89">More...</a><br/></td></tr>
<tr class="separator:a77b6eb98b7ba8c206526ad5fee940c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f918e0e51f7df56e21cb86946187f81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string_1_1const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a6f918e0e51f7df56e21cb86946187f81">rbegin</a> () const </td></tr>
<tr class="memdesc:a6f918e0e51f7df56e21cb86946187f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant iterator pointing to the first character of a reversed string, which corresponds to the last character of a normal string.  <a href="#a6f918e0e51f7df56e21cb86946187f81">More...</a><br/></td></tr>
<tr class="separator:a6f918e0e51f7df56e21cb86946187f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03697a891bb3c9b9fe83733cac48417c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a03697a891bb3c9b9fe83733cac48417c">rend</a> ()</td></tr>
<tr class="memdesc:a03697a891bb3c9b9fe83733cac48417c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing to the location succeeding the last character in a reversed string, which corresponds to the location preceding the first character in a normal string.  <a href="#a03697a891bb3c9b9fe83733cac48417c">More...</a><br/></td></tr>
<tr class="separator:a03697a891bb3c9b9fe83733cac48417c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6540f42871c12539feeb494ef9de11f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string_1_1const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a6540f42871c12539feeb494ef9de11f0">rend</a> () const </td></tr>
<tr class="memdesc:a6540f42871c12539feeb494ef9de11f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an constant iterator pointing to the location succeeding the last character in a reversed string, which corresponds to the location preceding the first character in a normal string.  <a href="#a6540f42871c12539feeb494ef9de11f0">More...</a><br/></td></tr>
<tr class="separator:a6540f42871c12539feeb494ef9de11f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31732db73e75bddb25b33f3bbe24e9f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a31732db73e75bddb25b33f3bbe24e9f4">replace</a> (const size_t position, const size_t count, const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;replacementString)</td></tr>
<tr class="memdesc:a31732db73e75bddb25b33f3bbe24e9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a section of this string and replaces it with the contents of another string.  <a href="#a31732db73e75bddb25b33f3bbe24e9f4">More...</a><br/></td></tr>
<tr class="separator:a31732db73e75bddb25b33f3bbe24e9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad091461591d02aff6af96921d144b4a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#ad091461591d02aff6af96921d144b4a3">replace</a> (const size_t position, const size_t count, const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;replacementString)</td></tr>
<tr class="memdesc:ad091461591d02aff6af96921d144b4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a section of this string and replaces it with the contents of another string.  <a href="#ad091461591d02aff6af96921d144b4a3">More...</a><br/></td></tr>
<tr class="separator:ad091461591d02aff6af96921d144b4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40313b7f22a7f984c58c254106bda278"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a40313b7f22a7f984c58c254106bda278">replace</a> (const size_t position, const size_t count, const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;replacementString)</td></tr>
<tr class="memdesc:a40313b7f22a7f984c58c254106bda278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a section of this string and replaces it with the contents of another string.  <a href="#a40313b7f22a7f984c58c254106bda278">More...</a><br/></td></tr>
<tr class="separator:a40313b7f22a7f984c58c254106bda278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896f80dec95874080a1d056426003184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a896f80dec95874080a1d056426003184">replace</a> (const size_t position, const size_t count, const size_t characterCount, const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> &amp;character)</td></tr>
<tr class="memdesc:a896f80dec95874080a1d056426003184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in a section of this string with the given character.  <a href="#a896f80dec95874080a1d056426003184">More...</a><br/></td></tr>
<tr class="separator:a896f80dec95874080a1d056426003184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc2387f06d5e1f405fec94111de1724"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a8cc2387f06d5e1f405fec94111de1724">replace</a> (<a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a> beginIterator, <a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a> endIterator, const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;replacementString)</td></tr>
<tr class="memdesc:a8cc2387f06d5e1f405fec94111de1724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a section of this string and replaces it with the contents of another string.  <a href="#a8cc2387f06d5e1f405fec94111de1724">More...</a><br/></td></tr>
<tr class="separator:a8cc2387f06d5e1f405fec94111de1724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0fdd85fe284ed6ac959e1463f6ebbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a6d0fdd85fe284ed6ac959e1463f6ebbc">replace</a> (<a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a> beginIterator, <a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a> endIterator, const size_t characterCount, const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> &amp;character)</td></tr>
<tr class="memdesc:a6d0fdd85fe284ed6ac959e1463f6ebbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the characters in a section of this string with the given character.  <a href="#a6d0fdd85fe284ed6ac959e1463f6ebbc">More...</a><br/></td></tr>
<tr class="separator:a6d0fdd85fe284ed6ac959e1463f6ebbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6f3c1b47590223be595a05086711f2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a0b6f3c1b47590223be595a05086711f2">rfind</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;searchString, size_t offset=<a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a>)</td></tr>
<tr class="memdesc:a0b6f3c1b47590223be595a05086711f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string backward for specific substring.  <a href="#a0b6f3c1b47590223be595a05086711f2">More...</a><br/></td></tr>
<tr class="separator:a0b6f3c1b47590223be595a05086711f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f60d5bb1c2db40325a6a385589c1b05"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a6f60d5bb1c2db40325a6a385589c1b05">rfind</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;searchString, size_t offset=<a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a>)</td></tr>
<tr class="memdesc:a6f60d5bb1c2db40325a6a385589c1b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string backward for specific substring.  <a href="#a6f60d5bb1c2db40325a6a385589c1b05">More...</a><br/></td></tr>
<tr class="separator:a6f60d5bb1c2db40325a6a385589c1b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d7de79946ce9b06c04cefa622b5960"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a55d7de79946ce9b06c04cefa622b5960">rfind</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;searchString, size_t offset=<a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a>)</td></tr>
<tr class="memdesc:a55d7de79946ce9b06c04cefa622b5960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches this string backward for specific substring.  <a href="#a55d7de79946ce9b06c04cefa622b5960">More...</a><br/></td></tr>
<tr class="separator:a55d7de79946ce9b06c04cefa622b5960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a08d10ce58ffc6ac6400196fa0ad50"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#ab9a08d10ce58ffc6ac6400196fa0ad50">size</a> () const </td></tr>
<tr class="memdesc:ab9a08d10ce58ffc6ac6400196fa0ad50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of code points in this string.  <a href="#ab9a08d10ce58ffc6ac6400196fa0ad50">More...</a><br/></td></tr>
<tr class="separator:ab9a08d10ce58ffc6ac6400196fa0ad50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8763707a5d360d5490e59ac9966e7728"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a8763707a5d360d5490e59ac9966e7728">substr</a> (const size_t offset=0, const size_t count=<a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a>)</td></tr>
<tr class="memdesc:a8763707a5d360d5490e59ac9966e7728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a substring of this string.  <a href="#a8763707a5d360d5490e59ac9966e7728">More...</a><br/></td></tr>
<tr class="separator:a8763707a5d360d5490e59ac9966e7728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57ea0924607bbfbf742e21e188b2321"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#ad57ea0924607bbfbf742e21e188b2321">swap</a> (<a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;unicodeString)</td></tr>
<tr class="memdesc:ad57ea0924607bbfbf742e21e188b2321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this string with those of another string.  <a href="#ad57ea0924607bbfbf742e21e188b2321">More...</a><br/></td></tr>
<tr class="separator:ad57ea0924607bbfbf742e21e188b2321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4794eab4345eb44cedc93c9c09ed0402"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a4794eab4345eb44cedc93c9c09ed0402">swap</a> (<a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String)</td></tr>
<tr class="memdesc:a4794eab4345eb44cedc93c9c09ed0402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this string with those of another string.  <a href="#a4794eab4345eb44cedc93c9c09ed0402">More...</a><br/></td></tr>
<tr class="separator:a4794eab4345eb44cedc93c9c09ed0402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12cd3b7af52cba4a94475ac88bcbffb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#af12cd3b7af52cba4a94475ac88bcbffb">swap</a> (<a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String)</td></tr>
<tr class="memdesc:af12cd3b7af52cba4a94475ac88bcbffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of this string with those of another string.  <a href="#af12cd3b7af52cba4a94475ac88bcbffb">More...</a><br/></td></tr>
<tr class="separator:af12cd3b7af52cba4a94475ac88bcbffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf23063921d45268b1044f80c57613fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_char_reference.html">UnicodeCharReference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#abf23063921d45268b1044f80c57613fd">operator[]</a> (const size_t index)</td></tr>
<tr class="memdesc:abf23063921d45268b1044f80c57613fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character found at the specified character index.  <a href="#abf23063921d45268b1044f80c57613fd">More...</a><br/></td></tr>
<tr class="separator:abf23063921d45268b1044f80c57613fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0874f3c217ae79590c6d3aa1873aef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a5c0874f3c217ae79590c6d3aa1873aef">operator[]</a> (const size_t index) const </td></tr>
<tr class="memdesc:a5c0874f3c217ae79590c6d3aa1873aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the character found at the specified character index.  <a href="#a5c0874f3c217ae79590c6d3aa1873aef">More...</a><br/></td></tr>
<tr class="separator:a5c0874f3c217ae79590c6d3aa1873aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24c78bd032c29ef8f5aa64b8c2002f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#af24c78bd032c29ef8f5aa64b8c2002f3">operator=</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;unicodeString)</td></tr>
<tr class="memdesc:af24c78bd032c29ef8f5aa64b8c2002f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of a <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> object to this object.  <a href="#af24c78bd032c29ef8f5aa64b8c2002f3">More...</a><br/></td></tr>
<tr class="separator:af24c78bd032c29ef8f5aa64b8c2002f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ef6eee94ae321d9416565278bb06fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a58ef6eee94ae321d9416565278bb06fe">operator=</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String)</td></tr>
<tr class="memdesc:a58ef6eee94ae321d9416565278bb06fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of a <a class="el" href="struct_utf_string_1_1_utf8_string.html" title="Contains and manages a UTF-8 string. ">Utf8String</a> object to this object.  <a href="#a58ef6eee94ae321d9416565278bb06fe">More...</a><br/></td></tr>
<tr class="separator:a58ef6eee94ae321d9416565278bb06fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9719b67283e53017bda98ffb2bdae13b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a9719b67283e53017bda98ffb2bdae13b">operator=</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String)</td></tr>
<tr class="memdesc:a9719b67283e53017bda98ffb2bdae13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the contents of a <a class="el" href="struct_utf_string_1_1_utf16_string.html" title="Contains and manages a UTF-16 string. ">Utf16String</a> object to this object.  <a href="#a9719b67283e53017bda98ffb2bdae13b">More...</a><br/></td></tr>
<tr class="separator:a9719b67283e53017bda98ffb2bdae13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa962bf5f93cfa940903364976e45ad45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#aa962bf5f93cfa940903364976e45ad45">operator==</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;otherString) const </td></tr>
<tr class="memdesc:aa962bf5f93cfa940903364976e45ad45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of another string and tests whether the two strings are the same.  <a href="#aa962bf5f93cfa940903364976e45ad45">More...</a><br/></td></tr>
<tr class="separator:aa962bf5f93cfa940903364976e45ad45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10bf551d7b6e3ab70c80d84df4476b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#aa10bf551d7b6e3ab70c80d84df4476b9">operator==</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String) const </td></tr>
<tr class="memdesc:aa10bf551d7b6e3ab70c80d84df4476b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of a UTF-8 string and tests whether the two strings are the same.  <a href="#aa10bf551d7b6e3ab70c80d84df4476b9">More...</a><br/></td></tr>
<tr class="separator:aa10bf551d7b6e3ab70c80d84df4476b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae044a1dcd0bf7d4c7506a0b1db657d2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#ae044a1dcd0bf7d4c7506a0b1db657d2c">operator==</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String) const </td></tr>
<tr class="memdesc:ae044a1dcd0bf7d4c7506a0b1db657d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of a UTF-16 string and tests whether the two strings are the same.  <a href="#ae044a1dcd0bf7d4c7506a0b1db657d2c">More...</a><br/></td></tr>
<tr class="separator:ae044a1dcd0bf7d4c7506a0b1db657d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd8d65c8e612693d3c987798e8f4188"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#accd8d65c8e612693d3c987798e8f4188">operator!=</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;otherString) const </td></tr>
<tr class="memdesc:accd8d65c8e612693d3c987798e8f4188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of another string and tests whether the two strings are the different.  <a href="#accd8d65c8e612693d3c987798e8f4188">More...</a><br/></td></tr>
<tr class="separator:accd8d65c8e612693d3c987798e8f4188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0f0242f549c2cabd068a0a26ec1b12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a9e0f0242f549c2cabd068a0a26ec1b12">operator!=</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String) const </td></tr>
<tr class="memdesc:a9e0f0242f549c2cabd068a0a26ec1b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of a UTF-8 string and tests whether the two strings are the different.  <a href="#a9e0f0242f549c2cabd068a0a26ec1b12">More...</a><br/></td></tr>
<tr class="separator:a9e0f0242f549c2cabd068a0a26ec1b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1bffec6c13bc71bd89827732ac083b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a2a1bffec6c13bc71bd89827732ac083b">operator!=</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String) const </td></tr>
<tr class="memdesc:a2a1bffec6c13bc71bd89827732ac083b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of a UTF-16 string and tests whether the two strings are the different.  <a href="#a2a1bffec6c13bc71bd89827732ac083b">More...</a><br/></td></tr>
<tr class="separator:a2a1bffec6c13bc71bd89827732ac083b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce80e8d67b532504ac2624499a7a9ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a5ce80e8d67b532504ac2624499a7a9ee">operator&lt;</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;otherString) const </td></tr>
<tr class="memdesc:a5ce80e8d67b532504ac2624499a7a9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of another string and tests whether the value of this string is less than the value of the other string.  <a href="#a5ce80e8d67b532504ac2624499a7a9ee">More...</a><br/></td></tr>
<tr class="separator:a5ce80e8d67b532504ac2624499a7a9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f34c719aba748a94a5b9bee56ab34bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a6f34c719aba748a94a5b9bee56ab34bd">operator&lt;</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String) const </td></tr>
<tr class="memdesc:a6f34c719aba748a94a5b9bee56ab34bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of a UTF-8 string and tests whether the value of this string is less than the value of the other string.  <a href="#a6f34c719aba748a94a5b9bee56ab34bd">More...</a><br/></td></tr>
<tr class="separator:a6f34c719aba748a94a5b9bee56ab34bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2481438f21c869c937ffe05f3fcd1f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#ae2481438f21c869c937ffe05f3fcd1f8">operator&lt;</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String) const </td></tr>
<tr class="memdesc:ae2481438f21c869c937ffe05f3fcd1f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of a UTF-16 string and tests whether the value of this string is less than the value of the other string.  <a href="#ae2481438f21c869c937ffe05f3fcd1f8">More...</a><br/></td></tr>
<tr class="separator:ae2481438f21c869c937ffe05f3fcd1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68eb9144329ed017a052244ab3dc7182"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a68eb9144329ed017a052244ab3dc7182">operator&lt;=</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;otherString) const </td></tr>
<tr class="memdesc:a68eb9144329ed017a052244ab3dc7182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of another string and tests whether the value of this string is less than or equal to the value of the other string.  <a href="#a68eb9144329ed017a052244ab3dc7182">More...</a><br/></td></tr>
<tr class="separator:a68eb9144329ed017a052244ab3dc7182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b277b4f2669eec9a99f21b5417c8995"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a1b277b4f2669eec9a99f21b5417c8995">operator&lt;=</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String) const </td></tr>
<tr class="memdesc:a1b277b4f2669eec9a99f21b5417c8995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of a UTF-8 string and tests whether the value of this string is less than or equal to the value of the other string.  <a href="#a1b277b4f2669eec9a99f21b5417c8995">More...</a><br/></td></tr>
<tr class="separator:a1b277b4f2669eec9a99f21b5417c8995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9375533e172c4beb30fcb9f965a67195"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a9375533e172c4beb30fcb9f965a67195">operator&lt;=</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String) const </td></tr>
<tr class="memdesc:a9375533e172c4beb30fcb9f965a67195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of a UTF-16 string and tests whether the value of this string is less than or equal to the value of the other string.  <a href="#a9375533e172c4beb30fcb9f965a67195">More...</a><br/></td></tr>
<tr class="separator:a9375533e172c4beb30fcb9f965a67195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21efcef08a31ffb6f540e3e79fcf5be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#aa21efcef08a31ffb6f540e3e79fcf5be">operator&gt;</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;otherString) const </td></tr>
<tr class="memdesc:aa21efcef08a31ffb6f540e3e79fcf5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of another string and tests whether the value of this string is greater than the value of the other string.  <a href="#aa21efcef08a31ffb6f540e3e79fcf5be">More...</a><br/></td></tr>
<tr class="separator:aa21efcef08a31ffb6f540e3e79fcf5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7873ceba5d755e3e52d4da64e3bb3e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a2c7873ceba5d755e3e52d4da64e3bb3e">operator&gt;</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String) const </td></tr>
<tr class="memdesc:a2c7873ceba5d755e3e52d4da64e3bb3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of a UTF-8 string and tests whether the value of this string is greater than the value of the other string.  <a href="#a2c7873ceba5d755e3e52d4da64e3bb3e">More...</a><br/></td></tr>
<tr class="separator:a2c7873ceba5d755e3e52d4da64e3bb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07321ef8c5caa5b369df2a81b110003"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#ac07321ef8c5caa5b369df2a81b110003">operator&gt;</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String) const </td></tr>
<tr class="memdesc:ac07321ef8c5caa5b369df2a81b110003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of a UTF-16 string and tests whether the value of this string is greater than the value of the other string.  <a href="#ac07321ef8c5caa5b369df2a81b110003">More...</a><br/></td></tr>
<tr class="separator:ac07321ef8c5caa5b369df2a81b110003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140213f4c44abc3bdb69ff3640f66de1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a140213f4c44abc3bdb69ff3640f66de1">operator&gt;=</a> (const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;otherString) const </td></tr>
<tr class="memdesc:a140213f4c44abc3bdb69ff3640f66de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of another string and tests whether the value of this string is greater than or equal to the value of the other string.  <a href="#a140213f4c44abc3bdb69ff3640f66de1">More...</a><br/></td></tr>
<tr class="separator:a140213f4c44abc3bdb69ff3640f66de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8076806a0a28a7d80e3ce0c175c2d9ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a8076806a0a28a7d80e3ce0c175c2d9ac">operator&gt;=</a> (const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;utf8String) const </td></tr>
<tr class="memdesc:a8076806a0a28a7d80e3ce0c175c2d9ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of a UTF-8 string and tests whether the value of this string is greater than or equal to the value of the other string.  <a href="#a8076806a0a28a7d80e3ce0c175c2d9ac">More...</a><br/></td></tr>
<tr class="separator:a8076806a0a28a7d80e3ce0c175c2d9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b93d612063204eab397c9cdffb66e72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a3b93d612063204eab397c9cdffb66e72">operator&gt;=</a> (const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;utf16String) const </td></tr>
<tr class="memdesc:a3b93d612063204eab397c9cdffb66e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the value of this string to the value of a UTF-16 string and tests whether the value of this string is greater than or equal to the value of the other string.  <a href="#a3b93d612063204eab397c9cdffb66e72">More...</a><br/></td></tr>
<tr class="separator:a3b93d612063204eab397c9cdffb66e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff578528aa0449a97633509bd2da22b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#aff578528aa0449a97633509bd2da22b2">operator Utf16String</a> () const </td></tr>
<tr class="memdesc:aff578528aa0449a97633509bd2da22b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object to a <a class="el" href="struct_utf_string_1_1_utf16_string.html" title="Contains and manages a UTF-16 string. ">Utf16String</a> object.  <a href="#aff578528aa0449a97633509bd2da22b2">More...</a><br/></td></tr>
<tr class="separator:aff578528aa0449a97633509bd2da22b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64583e085b68503b7d220c97bf15b6e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a64583e085b68503b7d220c97bf15b6e5">operator Utf8String</a> () const </td></tr>
<tr class="memdesc:a64583e085b68503b7d220c97bf15b6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts this object to a <a class="el" href="struct_utf_string_1_1_utf8_string.html" title="Contains and manages a UTF-8 string. ">Utf8String</a> object.  <a href="#a64583e085b68503b7d220c97bf15b6e5">More...</a><br/></td></tr>
<tr class="separator:a64583e085b68503b7d220c97bf15b6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a462f2b14a6a78daf9fb15bedb03366f1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a462f2b14a6a78daf9fb15bedb03366f1">IsWhitespace</a> (const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> &amp;unicodeCharacter)</td></tr>
<tr class="memdesc:a462f2b14a6a78daf9fb15bedb03366f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether a Unicode character is a whitespace character.  <a href="#a462f2b14a6a78daf9fb15bedb03366f1">More...</a><br/></td></tr>
<tr class="separator:a462f2b14a6a78daf9fb15bedb03366f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1362101b835563b746be6bb2c048c547"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1362101b835563b746be6bb2c048c547"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a></td></tr>
<tr class="memdesc:a1362101b835563b746be6bb2c048c547"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned integral value initialized to 1 that indicates either "not found" or "all remaining characters" when a search function fails. <br/></td></tr>
<tr class="separator:a1362101b835563b746be6bb2c048c547"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1a88b0374b3119befda9ffefe895e9b5"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a1a88b0374b3119befda9ffefe895e9b5">operator&gt;&gt;</a> (std::istream &amp;inputStream, <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;unicodeString)</td></tr>
<tr class="memdesc:a1a88b0374b3119befda9ffefe895e9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator reads a stream of bytes into a <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a>.  <a href="#a1a88b0374b3119befda9ffefe895e9b5">More...</a><br/></td></tr>
<tr class="separator:a1a88b0374b3119befda9ffefe895e9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b1b7a5aeb775841a2f318503a358a5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a55b1b7a5aeb775841a2f318503a358a5">operator&lt;&lt;</a> (std::ostream &amp;outputStream, const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;unicodeString)</td></tr>
<tr class="memdesc:a55b1b7a5aeb775841a2f318503a358a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator converts the contents of a <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> to a stream of bytes.  <a href="#a55b1b7a5aeb775841a2f318503a358a5">More...</a><br/></td></tr>
<tr class="separator:a55b1b7a5aeb775841a2f318503a358a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14729904560449291367f2dd85fd1be6"><td class="memItemLeft" align="right" valign="top">std::wistream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a14729904560449291367f2dd85fd1be6">operator&gt;&gt;</a> (std::wistream &amp;inputStream, <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;unicodeString)</td></tr>
<tr class="memdesc:a14729904560449291367f2dd85fd1be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator converts a wide stream of 16-bit values to a UTF-16 string and stores the UTF-16 string inside unicodeString.  <a href="#a14729904560449291367f2dd85fd1be6">More...</a><br/></td></tr>
<tr class="separator:a14729904560449291367f2dd85fd1be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a7f4162c19208853198b4f6d5b43c9"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utf_string_1_1_unicode_string.html#a90a7f4162c19208853198b4f6d5b43c9">operator&lt;&lt;</a> (std::wostream &amp;outputStream, const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;unicodeString)</td></tr>
<tr class="memdesc:a90a7f4162c19208853198b4f6d5b43c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operator converts a Unicode string to a wide stream of 16-bit values.  <a href="#a90a7f4162c19208853198b4f6d5b43c9">More...</a><br/></td></tr>
<tr class="separator:a90a7f4162c19208853198b4f6d5b43c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains and manages an encoding-neutral Unicode string. </p>
<p>This class is intended to be used in situations when the encoding of a Unicode string is unknown at compile time. <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> encapsulates and encoding-specific string, and abstracts away code units, concentrating on code points instead.</p>
<p><a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> is less efficient than the encoding-specific string classes (<a class="el" href="struct_utf_string_1_1_utf8_string.html" title="Contains and manages a UTF-8 string. ">Utf8String</a> and <a class="el" href="struct_utf_string_1_1_utf16_string.html" title="Contains and manages a UTF-16 string. ">Utf16String</a>), and due to the need to be encoding-neutral, contains less functionality than the encoding-specific strings. If you won't know the exact encoding until runtime, use <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a>; otherwise, use <a class="el" href="struct_utf_string_1_1_utf8_string.html" title="Contains and manages a UTF-8 string. ">Utf8String</a> or <a class="el" href="struct_utf_string_1_1_utf16_string.html" title="Contains and manages a UTF-16 string. ">Utf16String</a>.</p>
<p>A <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> can always be converted to a <a class="el" href="struct_utf_string_1_1_utf8_string.html" title="Contains and manages a UTF-8 string. ">Utf8String</a> or <a class="el" href="struct_utf_string_1_1_utf16_string.html" title="Contains and manages a UTF-16 string. ">Utf16String</a>. So if a string is coming from a source with an unknown encoding, such as a file, use <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> at first and then convert to a <a class="el" href="struct_utf_string_1_1_utf8_string.html" title="Contains and manages a UTF-8 string. ">Utf8String</a> or <a class="el" href="struct_utf_string_1_1_utf16_string.html" title="Contains and manages a UTF-16 string. ">Utf16String</a> for use in the rest of the application. <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> is most useful in library APIs or any other widely-used code, so functions can return a <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> object instead of implementing separate functions for each encoding. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="add9970b67ff2645828c0ba67a3ba6724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UtfString::UnicodeString::UnicodeString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeString</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialized this string with another <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeString</td><td>The <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> object to use to initialize this object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9e0801ec0038100c90493e033601fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UtfString::UnicodeString::UnicodeString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes this string with a UTF-16 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>A UTF-16 string used to initialize this object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02a7526d6c363369b10246f09d9a2470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UtfString::UnicodeString::UnicodeString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes this string with a UTF-8 string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A UTF-8 string used to initialize this object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a99931f94d340e3107de2891de5f2f4e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeString</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the contents of another string to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeString</td><td>A Unicode string to be appended</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a5bc249ff8a2357c7046a366bf8089e7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the contents of another string to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>A string of 16-bit code units to be appended</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="afef517ab69b9251fd974ba8aff15ec58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the contents of another string to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A UTF-8 string to be appended. The string is assumed to be a valid UTF-8 string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a8668e99942dba46afbd0e631490b64af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeCharacter</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a Unicode character to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeCharacter</td><td>A Unicode character to be appended. The character is assumed to be a valid Unicode character</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="af30ec0511d49d208a49f621b2702bc8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_char_reference.html">UnicodeCharReference</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeCharacterReference</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a Unicode character to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeCharacterReference</td><td>A reference to a Unicode character to be appended. The character is assumed to be a valid Unicode character</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="aa7edd215940479879f32db90773ffbe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeString</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the contents of another string to this string, replacing the current contents of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeString</td><td>A Unicode string to be assigned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a2fb831839e00a12876273a0c53041e3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the contents of another string to this string, replacing the current contents of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>A string of 16-bit code units to be assigned</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="ae06e305069de910e20eebdaabf94561a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the contents of another string to this string, replacing the current contents of this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A UTF-8 string to be assigned. The string is assumed to be a valid UTF-8 string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="ae0036026aeff0641bfaa9899965b7130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeCharacter</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a Unicode character to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeCharacter</td><td>A Unicode character to be assigned. The character is assumed to be a valid Unicode character</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a20ba531aaf19878f43e73009ad5ffc49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_char_reference.html">UnicodeCharReference</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeCharacterReference</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns a Unicode character to this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeCharacterReference</td><td>A reference to the Unicode character to be assigned. The character is assumed to be a valid Unicode character</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a8429e64a940c50e717c6748a47e41420"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_char_reference.html">UnicodeCharReference</a> UtfString::UnicodeString::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the character found at the specified character index. </p>
<p>This operator does for the validity of the index, and throws an out_of_range exception when the given index doesn't correspond to a character within a string. Note that operator[] is a faster way to access a specific character, but doesn't check for index validity.</p>
<p>Unicode strings are of variable length encoding, meaning that whereas accessing a character at a particular index is O(1) for fixed-length encodings, accessing a character in Unicode strings is O(1) in the best case and O(n) in the worst case.</p>
<p>So if you wish to iterate through the characters in this string, use the standard iterators instead of an indexer. The standard iterators will be far more efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of a character in the string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character found at the specified index </dd></dl>

</div>
</div>
<a class="anchor" id="a1916c60781c2a2a9205e7af8e948f2fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> UtfString::UnicodeString::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the character found at the specified character index. </p>
<p>This operator does for the validity of the index, and throws an out_of_range exception when the given index doesn't correspond to a character within a string. Note that operator[] is a faster way to access a specific character, but doesn't check for index validity.</p>
<p>Unicode strings are of variable length encoding, meaning that whereas accessing a character at a particular index is O(1) for fixed-length encodings, accessing a character in Unicode strings is O(1) in the best case and O(n) in the worst case.</p>
<p>So if you wish to iterate through the characters in this string, use the standard iterators instead of an indexer. The standard iterators will be far more efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of a character in the string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character found at the specified index </dd></dl>

</div>
</div>
<a class="anchor" id="aab52250a56b41db3654e4944fbc75efd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">iterator</a> UtfString::UnicodeString::begin </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first character of a string. </p>
<p>If the <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> is empty, an empty iterator is created. See the iterator class description for more information about empty iterators.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html" title="An iterator that iterates through the code points in a Unicode string. ">UnicodeString::iterator</a> </dd>
<dd>
<a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a" title="Indicates whether this is an empty string. ">UnicodeString::empty()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional iterator pointing to the first character in a string or just beyond the end of an empty string </dd></dl>

</div>
</div>
<a class="anchor" id="a0357f18a6fe0063ae565f98d7a259092"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string_1_1const__iterator.html">const_iterator</a> UtfString::UnicodeString::begin </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the first character of a string. </p>
<p>If the <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> is empty, an empty iterator is created. See the iterator class description for more information about empty iterators.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string_1_1const__iterator.html" title="An iterator that iterates through the code points in a Unicode string, but allowing only access to co...">UnicodeString::const_iterator</a> </dd>
<dd>
<a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a" title="Indicates whether this is an empty string. ">UnicodeString::empty()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional constant iterator pointing to the first character in a string or just beyond the end of an empty string </dd></dl>

</div>
</div>
<a class="anchor" id="aa106fbee8519fed07245193c559537a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UtfString::UnicodeString::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeString</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other. </p>
<p>If this string is the same as the parameter string, then the two strings are considered equal. If the strings are different, then one is considered to be less than the other. The strings are compared "alphabetically", and placed in "alphabetical" order. The string that comes before the other string in that order is considered to be less than higher-ordered other string.</p>
<p>Note that "alphabetical" order is used in quotations because it isn't truly alphabetical. Different languages have different symbols and may have complex rules for the ordering of characters. This class does not attempt to address those issues, but instead compares code points based on their Unicode value. So any particular Latin code point will be considered to be less than any particular Cyrillic code point, because the Cyrillic code points have higher Unicode values. Within the English language, the code points are numbered so that they will be compared according to the rules of the language. This may or may not be the case for code points used by other languages.</p>
<p>If language- or locale-specific comparison is necessary, it would be better to use the <a href="http://www.icu-project.org/">ICU</a> library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeString</td><td>A string to be compared to this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative number if this string is less than the parameter string, a zero if this string is equal to the parameter string, and a positive number if this string is greater than the parameter string </dd></dl>

</div>
</div>
<a class="anchor" id="ad1dce9b035f1528582fd91ce7e26feda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UtfString::UnicodeString::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other. </p>
<p>If this string is the same as the parameter string, then the two strings are considered equal. If the strings are different, then one is considered to be less than the other. The strings are compared "alphabetically", and placed in "alphabetical" order. The string that comes before the other string in that order is considered to be less than higher-ordered other string.</p>
<p>Note that "alphabetical" order is used in quotations because it isn't truly alphabetical. Different languages have different symbols and may have complex rules for the ordering of characters. This class does not attempt to address those issues, but instead compares code points based on their Unicode value. So any particular Latin code point will be considered to be less than any particular Cyrillic code point, because the Cyrillic code points have higher Unicode values. Within the English language, the code points are numbered so that they will be compared according to the rules of the language. This may or may not be the case for code points used by other languages.</p>
<p>If language- or locale-specific comparison is necessary, it would be better to use the <a href="http://www.icu-project.org/">ICU</a> library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>A string to be compared to this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative number if this string is less than the parameter string, a zero if this string is equal to the parameter string, and a positive number if this string is greater than the parameter string </dd></dl>

</div>
</div>
<a class="anchor" id="a8c53b3504ab64c379818907bfae26798"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UtfString::UnicodeString::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the code points in this string with a code points in another string to determine if both are equal or if one is less than the other. </p>
<p>If this string is the same as the parameter string, then the two strings are considered equal. If the strings are different, then one is considered to be less than the other. The strings are compared "alphabetically", and placed in "alphabetical" order. The string that comes before the other string in that order is considered to be less than higher-ordered other string.</p>
<p>Note that "alphabetical" order is used in quotations because it isn't truly alphabetical. Different languages have different symbols and may have complex rules for the ordering of characters. This class does not attempt to address those issues, but instead compares code points based on their Unicode value. So any particular Latin code point will be considered to be less than any particular Cyrillic code point, because the Cyrillic code points have higher Unicode values. Within the English language, the code points are numbered so that they will be compared according to the rules of the language. This may or may not be the case for code points used by other languages.</p>
<p>If language- or locale-specific comparison is necessary, it would be better to use the <a href="http://www.icu-project.org/">ICU</a> library.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A string to be compared to this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A negative number if this string is less than the parameter string, a zero if this string is equal to the parameter string, and a positive number if this string is greater than the parameter string </dd></dl>

</div>
</div>
<a class="anchor" id="a3627b11da000c224c56e0c77a9275f0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::empty </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether this is an empty string. </p>
<p>An empty <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> is one that has no internal data: it is completely empty container, ready to be assigned an encoding-specific string. </p>

</div>
</div>
<a class="anchor" id="afd69f2463de9cd0f729facf9382f235e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">iterator</a> UtfString::UnicodeString::end </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the location succeeding the last character in a string. </p>
<p>The iterator returned by this function is usually used to test whether an iterator has reached the end of a string. The iterator returned by this function should never be dereferenced, as it doesn't not point to a part of the string.</p>
<p>If the <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> is empty, an empty iterator is created. See the iterator class description for more information about empty iterators.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html" title="An iterator that iterates through the code points in a Unicode string. ">UnicodeString::iterator</a> </dd>
<dd>
<a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a" title="Indicates whether this is an empty string. ">UnicodeString::empty()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional iterator pointing to the location succeeding the last character in a string </dd></dl>

</div>
</div>
<a class="anchor" id="a4857670988d37e554eeb41b37e3ab799"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string_1_1const__iterator.html">const_iterator</a> UtfString::UnicodeString::end </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an constant iterator pointing to the location succeeding the last character in a string. </p>
<p>The iterator returned by this function is usually used to test whether an iterator has reached the end of a string. The iterator returned by this function should never be dereferenced, as it doesn't not point to a part of the string.</p>
<p>If the <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> is empty, an empty iterator is created. See the iterator class description for more information about empty iterators.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string_1_1const__iterator.html" title="An iterator that iterates through the code points in a Unicode string, but allowing only access to co...">UnicodeString::const_iterator</a> </dd>
<dd>
<a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a" title="Indicates whether this is an empty string. ">UnicodeString::empty()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional constant iterator pointing to the location succeeding the last character in a string </dd></dl>

</div>
</div>
<a class="anchor" id="ad62781e624b179f1840e6633a3b5cedf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a> UtfString::UnicodeString::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>firstPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>lastPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a range of characters from this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstPosition</td><td>An iterator pointing to the first character of the range to be removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lastPosition</td><td>An iterator pointing to the position one past the last character of the range to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first character after the range of characters that were removed, or an empty iterator if this string is empty</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a" title="Indicates whether this is an empty string. ">UnicodeString::empty()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afc48cc464115565a4640c5c8ee9ba14e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a> UtfString::UnicodeString::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a character from this string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>An iterator pointing to the character to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the first character after character that was removed, or an empty iterator if this string is empty</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a" title="Indicates whether this is an empty string. ">UnicodeString::empty()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7a6452573378b8b8c329ab28b1e83b25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::erase </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code><a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a range of characters from this string. </p>
<p>This function will only cause characters to be removed up to the end of the string, so an overly large count parameter value will not cause problems.</p>
<p>This function assumes that offset &lt;= <a class="el" href="class_utf_string_1_1_unicode_string.html#a6712e63301f5b44c7248b2e8bdb21c27" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The offset describing the index location of the first character to be removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The maximum number of characters to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the specified range of characters have been removed </dd></dl>

</div>
</div>
<a class="anchor" id="a728660484a542f07c0d95ccff4f2b617"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for specific substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The substring to be found in this string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index at which the substring was found, or npos if the substring was not found </dd></dl>

</div>
</div>
<a class="anchor" id="afffd41786cbae08a92ff198ac42378bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for specific substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The substring to be found in this string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index at which the substring was found, or npos if the substring was not found </dd></dl>

</div>
</div>
<a class="anchor" id="a73898e445cc8ed9146c14005f65350e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for specific substring. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The substring to be found in this string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index at which the substring was found, or npos if the substring was not found </dd></dl>

</div>
</div>
<a class="anchor" id="a1bf5d6a8f549d2641a2cfe6b1d9cc1e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the first character that is not found in a given string. </p>
<p>Note that if searchString is not a valid Unicode string, this function will still work, but the result may turn up an unexpected code point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be excluded in the search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character in this string that is not a character in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="a14a042a0dd499663bf7966c6dc8bc42d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the first character that is not found in a given string. </p>
<p>Note that if searchString is not a valid UTF-8 string, this function will still work, but the result may turn up an unexpected code point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be excluded in the search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character in this string that is not a character in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="a57d6b5ead3d1c649c274451e221072da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::find_first_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the first character that is not found in a given string. </p>
<p>Note that if searchString is not a valid UTF-16 string, this function will still work, but the result may turn up an unexpected code point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be excluded in the search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character in this string that is not a character in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="a75640399669e0165176b998a7ea82010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the first character that is found in a given string. </p>
<p>This function differes from <a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617" title="Searches this string for specific substring. ">find()</a> in that <a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617" title="Searches this string for specific substring. ">find()</a> searches for the exact occurrance of the search string whereas this function searches for any one of the characters found in the search string.</p>
<p>This function assumes <a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371" title="Indicates whether this string is a valid Unicode string. ">is_valid()</a> is true and searchString.is_valid() is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be searched for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character in this string that is also in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="a83cebf60e909490ce5194d998eaee2f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the first character that is found in a given string. </p>
<p>This function differes from <a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617" title="Searches this string for specific substring. ">find()</a> in that <a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617" title="Searches this string for specific substring. ">find()</a> searches for the exact occurrance of the search string whereas this function searches for any one of the characters found in the search string.</p>
<p>This function assumes <a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371" title="Indicates whether this string is a valid Unicode string. ">is_valid()</a> is true and searchString.is_valid() is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be searched for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character in this string that is also in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="a72b959d9e0cb0d769c2fb9b9701c7067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::find_first_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the first character that is found in a given string. </p>
<p>This function differes from <a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617" title="Searches this string for specific substring. ">find()</a> in that <a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617" title="Searches this string for specific substring. ">find()</a> searches for the exact occurrance of the search string whereas this function searches for any one of the characters found in the search string.</p>
<p>This function assumes <a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371" title="Indicates whether this string is a valid Unicode string. ">is_valid()</a> is true and searchString.is_valid() is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be searched for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the first character in this string that is also in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="a0779c7d3ee935d3df937efa7b02fcab8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the last character that is not found in a given string. </p>
<p>Note that if searchString is not a valid Unicode string, this function will still work, but the result may turn up an unexpected code point.</p>
<p>Please note that the offset in this function controls the index where the search <em>ends</em>, and not where it begins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be excluded in the search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to finish</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last character in this string that is not a character in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="a1d1d0f0044ac65b161b6e02c6ae113ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the last character that is not found in a given string. </p>
<p>Note that if searchString is not a valid UTF-8 string, this function will still work, but the result may turn up an unexpected code point.</p>
<p>Please note that the offset in this function controls the index where the search <em>ends</em>, and not where it begins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be excluded in the search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to finish</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last character in this string that is not a character in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="a01765e8c9151c25902a408aaa69e692a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::find_last_not_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the last character that is not found in a given string. </p>
<p>Note that if searchString is not a valid UTF-16 string, this function will still work, but the result may turn up an unexpected code point. For example, if the search string contains only the second code unit of a two-code-unit code point, that code point in the string being searched may still be the character identified by the search result, because even though the second code unit was in the search string, the first code unit of that code point was not. This is because there are numerous code points that could have that second code unit, and there is no way to distinguish between them if we are only given one code unit.</p>
<p>Please note that the offset in this function controls the index where the search <em>ends</em>, and not where it begins.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be excluded in the search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to finish</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last character in this string that is not a character in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="afd72ddfff4e3d0194b5fffca21c5028d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the last character that is found in a given string. </p>
<p>This function differes from <a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617" title="Searches this string for specific substring. ">find()</a> in that <a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617" title="Searches this string for specific substring. ">find()</a> searches for the exact occurrance of the search string whereas this function searches for any one of the characters found in the search string.</p>
<p>Please note that the offset in this function controls the index where the search <em>ends</em>, and not where it begins.</p>
<p>This function assumes <a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371" title="Indicates whether this string is a valid Unicode string. ">is_valid()</a> is true and searchString.is_valid() is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be searched for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to finish</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last character in this string that is also in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="a4b26f8359d2d380ef3ea040db5792ae9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the last character that is found in a given string. </p>
<p>This function differes from <a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617" title="Searches this string for specific substring. ">find()</a> in that <a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617" title="Searches this string for specific substring. ">find()</a> searches for the exact occurrance of the search string whereas this function searches for any one of the characters found in the search string.</p>
<p>Please note that the offset in this function controls the index where the search <em>ends</em>, and not where it begins.</p>
<p>This function assumes <a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371" title="Indicates whether this string is a valid Unicode string. ">is_valid()</a> is true and searchString.is_valid() is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be searched for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to finish</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last character in this string that is also in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="a6e7dd07fdc8b30357042fc1811a47903"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::find_last_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string for the last character that is found in a given string. </p>
<p>This function differes from <a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617" title="Searches this string for specific substring. ">find()</a> in that <a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617" title="Searches this string for specific substring. ">find()</a> searches for the exact occurrance of the search string whereas this function searches for any one of the characters found in the search string.</p>
<p>Please note that the offset in this function controls the index where the search <em>ends</em>, and not where it begins.</p>
<p>This function assumes <a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371" title="Indicates whether this string is a valid Unicode string. ">is_valid()</a> is true and searchString.is_valid() is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The string containing the characters that are to be searched for </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to finish</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the last character in this string that is also in searchString, or npos if no such character was found </dd></dl>

</div>
</div>
<a class="anchor" id="aca820b8149f155e6c02fbce13b3f45a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::insert </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the contents of another string into this string at a specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index in this string where the parameter string is to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeString</td><td>A Unicode string to be appended</td></tr>
  </table>
  </dd>
</dl>
<p>Note that text can be inserted at the end of the string by specifying an index one past the end of the string.</p>
<p>This function assumes index &lt;= <a class="el" href="class_utf_string_1_1_unicode_string.html#a6712e63301f5b44c7248b2e8bdb21c27" title="Returns the number of code points in this string. ">length()</a>, <a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371" title="Indicates whether this string is a valid Unicode string. ">is_valid()</a> == true, and unicodeString.is_valid() == true.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a20c83ce972b4ec14e90b5b407d6d4e6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::insert </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the contents of another string into this string at a specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index in this string where the parameter string is to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>A UTF-8 string to be appended</td></tr>
  </table>
  </dd>
</dl>
<p>Note that text can be inserted at the end of the string by specifying an index one past the end of the string.</p>
<p>This function assumes index &lt;= <a class="el" href="class_utf_string_1_1_unicode_string.html#a6712e63301f5b44c7248b2e8bdb21c27" title="Returns the number of code points in this string. ">length()</a>, <a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371" title="Indicates whether this string is a valid Unicode string. ">is_valid()</a> == true, and unicodeString.is_valid() == true.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a2e31e7a146b50b6096d49bb2df5c4a77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::insert </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts the contents of another string into this string at a specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index in this string where the parameter string is to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>A UTF-16 string to be appended</td></tr>
  </table>
  </dd>
</dl>
<p>Note that text can be inserted at the end of the string by specifying an index one past the end of the string.</p>
<p>This function assumes index &lt;= <a class="el" href="class_utf_string_1_1_unicode_string.html#a6712e63301f5b44c7248b2e8bdb21c27" title="Returns the number of code points in this string. ">length()</a>, <a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371" title="Indicates whether this string is a valid Unicode string. ">is_valid()</a> == true, and unicodeString.is_valid() == true.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a0762a0934a70a9dfb30521176a947010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::insert </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeCharacter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a character into this string at a specified index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index in this string where the character is to be inserted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeCharacter</td><td>A Unicode character to be appended. The character is assumed to be a valid Unicode character</td></tr>
  </table>
  </dd>
</dl>
<p>Note that character can be inserted at the end of the string by specifying an index one past the end of the string.</p>
<p>This function assumes unicodeCharacter is a valid character and that index &lt;= <a class="el" href="class_utf_string_1_1_unicode_string.html#a6712e63301f5b44c7248b2e8bdb21c27" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string </dd></dl>

</div>
</div>
<a class="anchor" id="a83b2fecfac699d42b37e849350cda68c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_utf_string.html#ae8b43f83cfd3f6aefcd2f9c65826dfbb">UtfEncoding</a> UtfString::UnicodeString::internal_encoding </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates the internal encoding used by this string. </p>
<p>The internal encoding of a <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> depends on what data is used to initialize the string or what data is assigned to the string when it is empty. If a <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> is initialized with a UTF-8 string, the internal encoding will be UTF-8. In this case, any operations involving a UTF-16 string will result in the UTF-16 string being converted to UTF-8 internally. The opposite is the case when a <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> is initialized with a UTF-16 string. This is done to keep encoding conversions to a minimum. If an application is dealing primarily with one encoding, and a string in that encoding is put in a <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a>, we avoid the conversion to a specific internal encoding and then the conversion back to the original encoding.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a" title="Indicates whether this is an empty string. ">UnicodeString::empty()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a609ad252e64f3a3565c2a38109c08371"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::is_valid </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether this string is a valid Unicode string. </p>
<p>A valid Unicode string is a string whose encapsulated encoding-specific string is comprised of valid code units.</p>
<p>An empty string is considered to be a valid Unicode string</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a" title="Indicates whether this is an empty string. ">UnicodeString::empty()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if this string is a valid Unicode string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a462f2b14a6a78daf9fb15bedb03366f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool UtfString::UnicodeString::IsWhitespace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeCharacter</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether a Unicode character is a whitespace character. </p>
<p>This function tests for the standard ASCII whitespace characters(tab, space, carriage return, line feed), and the characters that the Unicode standard defines as being separator characters.</p>
<p>An empty character is not considered to be a whitespace character.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a" title="Indicates whether this is an empty string. ">UnicodeString::empty()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeCharacter</td><td>The character to be examined</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If unicodeCharacter is a whitespace character, true, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a6712e63301f5b44c7248b2e8bdb21c27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::length </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of code points in this string. </p>
<p>Use this function if you're interested in how many characters are in a string.</p>
<p>This function does not check for validity, so it may return an incorrect result if <a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371" title="Indicates whether this string is a valid Unicode string. ">is_valid()</a> is false.</p>
<p>This function has a O(N) performance, since we need to iterate through the code units to figure out how many code points there are. Counting each code point is an extremely quick operation, but due to the need to visit every code point in the string, it would be wise to be mindful of performance when making heavy use of this function on long strings in performance-sensitive code.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of code points in this string </dd></dl>

</div>
</div>
<a class="anchor" id="aff578528aa0449a97633509bd2da22b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UtfString::UnicodeString::operator <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this object to a <a class="el" href="struct_utf_string_1_1_utf16_string.html" title="Contains and manages a UTF-16 string. ">Utf16String</a> object. </p>
<p>This operator assumes that if this string is non-empty, it is a valid Unicode string.</p>
<p>If this object does not contain a string, an empty <a class="el" href="struct_utf_string_1_1_utf16_string.html" title="Contains and manages a UTF-16 string. ">Utf16String</a> will be returned</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371" title="Indicates whether this string is a valid Unicode string. ">UnicodeString::is_valid()</a> </dd>
<dd>
<a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a" title="Indicates whether this is an empty string. ">UnicodeString::empty()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a64583e085b68503b7d220c97bf15b6e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UtfString::UnicodeString::operator <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts this object to a <a class="el" href="struct_utf_string_1_1_utf8_string.html" title="Contains and manages a UTF-8 string. ">Utf8String</a> object. </p>
<p>This operator assumes that if this string is non-empty, it is a valid Unicode string.</p>
<p>If this object does not contain a string, an empty <a class="el" href="struct_utf_string_1_1_utf8_string.html" title="Contains and manages a UTF-8 string. ">Utf8String</a> will be returned</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371" title="Indicates whether this string is a valid Unicode string. ">UnicodeString::is_valid()</a> </dd>
<dd>
<a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a" title="Indicates whether this is an empty string. ">UnicodeString::empty()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="accd8d65c8e612693d3c987798e8f4188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>otherString</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of another string and tests whether the two strings are the different. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherString</td><td>The string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two strings are different, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a9e0f0242f549c2cabd068a0a26ec1b12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of a UTF-8 string and tests whether the two strings are the different. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>The UTF-8 string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two strings are different, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a2a1bffec6c13bc71bd89827732ac083b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of a UTF-16 string and tests whether the two strings are the different. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>The UTF-16 string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two strings are different, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a5ce80e8d67b532504ac2624499a7a9ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>otherString</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of another string and tests whether the value of this string is less than the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherString</td><td>The string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is less than the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a6f34c719aba748a94a5b9bee56ab34bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of a UTF-8 string and tests whether the value of this string is less than the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>The UTF-8 string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is less than the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="ae2481438f21c869c937ffe05f3fcd1f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of a UTF-16 string and tests whether the value of this string is less than the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>The UTF-16 string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is less than the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a68eb9144329ed017a052244ab3dc7182"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>otherString</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of another string and tests whether the value of this string is less than or equal to the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherString</td><td>The string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is less than or equal to the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a1b277b4f2669eec9a99f21b5417c8995"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of a UTF-8 string and tests whether the value of this string is less than or equal to the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>The UTF-8 string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is less than or equal to the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a9375533e172c4beb30fcb9f965a67195"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of a UTF-16 string and tests whether the value of this string is less than or equal to the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>The UTF-16 string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is less than or equal to the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="af24c78bd032c29ef8f5aa64b8c2002f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeString</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the contents of a <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> object to this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeString</td><td>The <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> object whose contents are to be assigned to this object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a58ef6eee94ae321d9416565278bb06fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the contents of a <a class="el" href="struct_utf_string_1_1_utf8_string.html" title="Contains and manages a UTF-8 string. ">Utf8String</a> object to this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>The Utf8StringString object whose contents are to be assigned to this object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="a9719b67283e53017bda98ffb2bdae13b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the contents of a <a class="el" href="struct_utf_string_1_1_utf16_string.html" title="Contains and manages a UTF-16 string. ">Utf16String</a> object to this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>The Utf16StringString object whose contents are to be assigned to this object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this object </dd></dl>

</div>
</div>
<a class="anchor" id="aa962bf5f93cfa940903364976e45ad45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>otherString</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of another string and tests whether the two strings are the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherString</td><td>The string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two strings are equal, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="aa10bf551d7b6e3ab70c80d84df4476b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of a UTF-8 string and tests whether the two strings are the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>The UTF-8 string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two strings are equal, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="ae044a1dcd0bf7d4c7506a0b1db657d2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of a UTF-16 string and tests whether the two strings are the same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>The UTF-16 string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two strings are the equal, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="aa21efcef08a31ffb6f540e3e79fcf5be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>otherString</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of another string and tests whether the value of this string is greater than the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherString</td><td>The string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is greater than the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a2c7873ceba5d755e3e52d4da64e3bb3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of a UTF-8 string and tests whether the value of this string is greater than the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>The UTF-8 string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is greater than the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="ac07321ef8c5caa5b369df2a81b110003"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of a UTF-16 string and tests whether the value of this string is greater than the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>The UTF-16 string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is greater than the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a140213f4c44abc3bdb69ff3640f66de1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>otherString</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of another string and tests whether the value of this string is greater than or equal to the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherString</td><td>The string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is greater than or equal to the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a8076806a0a28a7d80e3ce0c175c2d9ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of a UTF-8 string and tests whether the value of this string is greater than or equal to the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>The string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is greater than or equal to the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="a3b93d612063204eab397c9cdffb66e72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UtfString::UnicodeString::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares the value of this string to the value of a UTF-16 string and tests whether the value of this string is greater than or equal to the value of the other string. </p>
<p>The values of each string are determined by the Unicode values of the characters. This is the similar comparing strings in alphabetical order, where the character order is determined by the Unicode values and not the ordering of any particular alphabet.</p>
<p>In practice, this works out to be the same as alphabetical ordering for English- language strings, but may not be for strings in other languages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>The UTF-16 string to be compared with this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the the value of this string is greater than or equal to the value of the other string, otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="abf23063921d45268b1044f80c57613fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_char_reference.html">UnicodeCharReference</a> UtfString::UnicodeString::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the character found at the specified character index. </p>
<p>This operator does not check for the validity of the index, so it assumes that index is valid. What happens when the index is invalid is undefined. If you want the index parameter to be validated, use the <a class="el" href="class_utf_string_1_1_unicode_string.html#a8429e64a940c50e717c6748a47e41420" title="Returns a reference to the character found at the specified character index. ">at()</a> function instead.</p>
<p>Unicode strings are of variable length encoding, meaning that whereas accessing a character at a particular index is O(1) for fixed-length encodings, accessing a character in Unicode strings is O(1) in the best case and O(n) in the worst case.</p>
<p>So if you wish to iterate through the characters in this string, use the standard iterators instead of an indexer. The standard iterators will be far more efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index identifying the character to be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character found at the specified index </dd></dl>

</div>
</div>
<a class="anchor" id="a5c0874f3c217ae79590c6d3aa1873aef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> UtfString::UnicodeString::operator[] </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the character found at the specified character index. </p>
<p>This operator does not check for the validity of the index, so it assumes that index is valid. What happens when the index is invalid is undefined. If you want the index parameter to be validated, use the <a class="el" href="class_utf_string_1_1_unicode_string.html#a8429e64a940c50e717c6748a47e41420" title="Returns a reference to the character found at the specified character index. ">at()</a> function instead.</p>
<p>Unicode strings are of variable length encoding, meaning that whereas accessing a character at a particular index is O(1) for fixed-length encodings, accessing a character in Unicode strings is O(1) in the best case and O(n) in the worst case.</p>
<p>So if you wish to iterate through the characters in this string, use the standard iterators instead of an indexer. The standard iterators will be far more efficient.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index identifying the character to be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character found at the specified index </dd></dl>

</div>
</div>
<a class="anchor" id="a71d03386f3d45da5888df789f7011041"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UtfString::UnicodeString::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> &amp;&#160;</td>
          <td class="paramname"><em>character</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a character to the end of this string. </p>
<p>This function is the equivalent of calling insert(<a class="el" href="class_utf_string_1_1_unicode_string.html#a6712e63301f5b44c7248b2e8bdb21c27" title="Returns the number of code points in this string. ">length()</a>, character) or append(character).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">character</td><td>The character to be appended to the end of this string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77b6eb98b7ba8c206526ad5fee940c89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string_1_1reverse__iterator.html">reverse_iterator</a> UtfString::UnicodeString::rbegin </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the first character of a reversed string, which corresponds to the last character of the normal string. </p>
<p>If the <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> is empty, an empty iterator is created. See the iterator class description for more information about empty iterators.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string_1_1reverse__iterator.html" title="An iterator that iterates through the code points in a Unicode string in reverse order. ">UnicodeString::reverse_iterator</a> </dd>
<dd>
<a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a" title="Indicates whether this is an empty string. ">UnicodeString::empty()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional iterator pointing to the first character in a reversed string or just beyond the end of an empty reversed string </dd></dl>

</div>
</div>
<a class="anchor" id="a6f918e0e51f7df56e21cb86946187f81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string_1_1const__reverse__iterator.html">const_reverse_iterator</a> UtfString::UnicodeString::rbegin </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant iterator pointing to the first character of a reversed string, which corresponds to the last character of a normal string. </p>
<p>If the <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> is empty, an empty iterator is created. See the iterator class description for more information about empty iterators.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string_1_1const__reverse__iterator.html" title="An iterator that iterates through the code points in a Unicode string in reverse order, but allowing only access to constant code points. ">UnicodeString::const_reverse_iterator</a> </dd>
<dd>
<a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a" title="Indicates whether this is an empty string. ">UnicodeString::empty()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional constant iterator pointing to the first character in a reversed string or just beyond the end of an empty reversed string </dd></dl>

</div>
</div>
<a class="anchor" id="a03697a891bb3c9b9fe83733cac48417c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string_1_1reverse__iterator.html">reverse_iterator</a> UtfString::UnicodeString::rend </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator pointing to the location succeeding the last character in a reversed string, which corresponds to the location preceding the first character in a normal string. </p>
<p>The iterator returned by this function is usually used to test whether an iterator has reached the end of a string. The iterator returned by this function should never be dereferenced, as it doesn't not point to a part of the string.</p>
<p>If the <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> is empty, an empty iterator is created. See the iterator class description for more information about empty iterators.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string_1_1reverse__iterator.html" title="An iterator that iterates through the code points in a Unicode string in reverse order. ">UnicodeString::reverse_iterator</a> </dd>
<dd>
<a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a" title="Indicates whether this is an empty string. ">UnicodeString::empty()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional iterator pointing to the location succeeding the last character in a reversed string </dd></dl>

</div>
</div>
<a class="anchor" id="a6540f42871c12539feeb494ef9de11f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string_1_1const__reverse__iterator.html">const_reverse_iterator</a> UtfString::UnicodeString::rend </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an constant iterator pointing to the location succeeding the last character in a reversed string, which corresponds to the location preceding the first character in a normal string. </p>
<p>The iterator returned by this function is usually used to test whether an iterator has reached the end of a string. The iterator returned by this function should never be dereferenced, as it doesn't not point to a part of the string.</p>
<p>If the <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> is empty, an empty iterator is created. See the iterator class description for more information about empty iterators.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string_1_1const__reverse__iterator.html" title="An iterator that iterates through the code points in a Unicode string in reverse order, but allowing only access to constant code points. ">UnicodeString::const_reverse_iterator</a> </dd>
<dd>
<a class="el" href="class_utf_string_1_1_unicode_string.html#a3627b11da000c224c56e0c77a9275f0a" title="Indicates whether this is an empty string. ">UnicodeString::empty()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A bidirectional constant iterator pointing to the location succeeding the last character in a reversed string </dd></dl>

</div>
</div>
<a class="anchor" id="a31732db73e75bddb25b33f3bbe24e9f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::replace </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>replacementString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a section of this string and replaces it with the contents of another string. </p>
<p>Note that if position is one index past the end of the string, replacementString will simply be appended to the end of the string.</p>
<p>This function assumes position &lt;= <a class="el" href="class_utf_string_1_1_unicode_string.html#a6712e63301f5b44c7248b2e8bdb21c27" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The index in the string identifying the beginning of the string section to be removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The maximum number of characters to be removed from this string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacementString</td><td>The string whose contents are to replace the section being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the replacement has been completed </dd></dl>

</div>
</div>
<a class="anchor" id="ad091461591d02aff6af96921d144b4a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::replace </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>replacementString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a section of this string and replaces it with the contents of another string. </p>
<p>Note that if position is one index past the end of the string, replacementString will simply be appended to the end of the string.</p>
<p>This function assumes position &lt;= <a class="el" href="class_utf_string_1_1_unicode_string.html#a6712e63301f5b44c7248b2e8bdb21c27" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The index in the string identifying the beginning of the string section to be removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The maximum number of characters to be removed from this string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacementString</td><td>The string whose contents are to replace the section being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the replacement has been completed </dd></dl>

</div>
</div>
<a class="anchor" id="a40313b7f22a7f984c58c254106bda278"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::replace </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>replacementString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a section of this string and replaces it with the contents of another string. </p>
<p>Note that if position is one index past the end of the string, replacementString will simply be appended to the end of the string.</p>
<p>This function assumes position &lt;= <a class="el" href="class_utf_string_1_1_unicode_string.html#a6712e63301f5b44c7248b2e8bdb21c27" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The index in the string identifying the beginning of the string section to be removed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The maximum number of characters to be removed from this string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacementString</td><td>The string whose contents are to replace the section being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the replacement has been completed </dd></dl>

</div>
</div>
<a class="anchor" id="a896f80dec95874080a1d056426003184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::replace </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>characterCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> &amp;&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the characters in a section of this string with the given character. </p>
<p>This function assumes position &lt;= <a class="el" href="class_utf_string_1_1_unicode_string.html#a6712e63301f5b44c7248b2e8bdb21c27" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>The index in the string identifying the first character to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The maximum number of characters to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">characterCount</td><td>The number of times the character is to be repeated in the replaced section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">character</td><td>The character to replace the characters in the identified section of this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the replacement has been completed </dd></dl>

</div>
</div>
<a class="anchor" id="a8cc2387f06d5e1f405fec94111de1724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a>&#160;</td>
          <td class="paramname"><em>beginIterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a>&#160;</td>
          <td class="paramname"><em>endIterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>replacementString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a section of this string and replaces it with the contents of another string. </p>
<p>This function replaces the section of the string from beginIterator to endIterator - 1, where endIterator is pointing at a position one past the end of the section to be replaced.</p>
<p>If endIterator points to a position before beginIterator, endIterator is ignored and the entire string from beginIterator to the end of the string is replaced. If beginIterator points to the same position as endIterator, replacementString is simply inserted at that position and nothing in this string is removed.</p>
<p>If this string is an empty string, then neither of the iterators passed in can be valid non-empty iterators. In this case, the empty string is replaced with the contents of replacementString.</p>
<p>This function assumes that beginIterator and endIterator are iterators for this string. This function also assumes that beginIterator and endIterator are both valid iterators when this string is non-empty or that beginIterator and endIterator are both empty iterators when this string is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beginIterator</td><td>An iterator pointing to the first character of the string section to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endIterator</td><td>An iterator pointing to the position one past the last character of the string section to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">replacementString</td><td>The string whose contents are to replace the section being removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the replacement has been completed </dd></dl>

</div>
</div>
<a class="anchor" id="a6d0fdd85fe284ed6ac959e1463f6ebbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a>&amp; UtfString::UnicodeString::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a>&#160;</td>
          <td class="paramname"><em>beginIterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_utf_string_1_1_unicode_string_1_1iterator.html">UnicodeString::iterator</a>&#160;</td>
          <td class="paramname"><em>endIterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>characterCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_char.html">UnicodeChar</a> &amp;&#160;</td>
          <td class="paramname"><em>character</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the characters in a section of this string with the given character. </p>
<p>This function replaces the section of the string from beginIterator to endIterator - 1, where endIterator is pointing at a position one past the end of the section to be replaced.</p>
<p>If endIterator points to a position before beginIterator, endIterator is ignored and the entire string from beginIterator to the end of the string is replaced. If beginIterator points to the same position as endIterator, the new characters are simply inserted at that position and nothing in this string is removed.</p>
<p>If this string is an empty string, then neither of the iterators passed in can be valid non-empty iterators. In this case, the empty string is replaced with the contents of replacementString.</p>
<p>This function assumes that beginIterator and endIterator are iterators for this string. This function also assumes that beginIterator and endIterator are both valid iterators when this string is non-empty or that beginIterator and endIterator are both empty iterators when this string is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">beginIterator</td><td>An iterator pointing to the first character of the string section to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endIterator</td><td>An iterator pointing to the position one past the last character of the string section to be replaced </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">characterCount</td><td>The number of times the character is to be repeated in the replaced section </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">character</td><td>The character to replace the characters in the identified section of this string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this string after the replacement has been completed </dd></dl>

</div>
</div>
<a class="anchor" id="a0b6f3c1b47590223be595a05086711f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string backward for specific substring. </p>
<p>Note this does not look at the characters in reverse order like iterating through a string with a reverse iterator. It looks at the characters in forward order just like the <a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617" title="Searches this string for specific substring. ">find()</a> function, but starts at the end of the string and works backward toward the beginning.</p>
<p>This function assumes that searchString.is_valid() is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The substring to be found in this string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index at which the substring was found, or npos if the substring was not found </dd></dl>

</div>
</div>
<a class="anchor" id="a6f60d5bb1c2db40325a6a385589c1b05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string backward for specific substring. </p>
<p>Note this does not look at the characters in reverse order like iterating through a string with a reverse iterator. It looks at the characters in forward order just like the <a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617" title="Searches this string for specific substring. ">find()</a> function, but starts at the end of the string and works backward toward the beginning.</p>
<p>This function assumes that searchString.is_valid() is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The substring to be found in this string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index at which the substring was found, or npos if the substring was not found </dd></dl>

</div>
</div>
<a class="anchor" id="a55d7de79946ce9b06c04cefa622b5960"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>searchString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code><a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches this string backward for specific substring. </p>
<p>Note this does not look at the characters in reverse order like iterating through a string with a reverse iterator. It looks at the characters in forward order just like the <a class="el" href="class_utf_string_1_1_unicode_string.html#a728660484a542f07c0d95ccff4f2b617" title="Searches this string for specific substring. ">find()</a> function, but starts at the end of the string and works backward toward the beginning.</p>
<p>This function assumes that searchString.is_valid() is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">searchString</td><td>The substring to be found in this string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The index of the string at which the search is to begin</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index at which the substring was found, or npos if the substring was not found </dd></dl>

</div>
</div>
<a class="anchor" id="ab9a08d10ce58ffc6ac6400196fa0ad50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UtfString::UnicodeString::size </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of code points in this string. </p>
<p>This function is exactly the same as the <a class="el" href="class_utf_string_1_1_unicode_string.html#a6712e63301f5b44c7248b2e8bdb21c27" title="Returns the number of code points in this string. ">length()</a> function. We just include it here because it is a standard function in most string and STL classes.</p>
<p>This function has a O(N) performance, since we need to iterate through the code units to figure out how many code points there are. Counting each code point is an extremely quick operation, but due to the need to visit every code point in the string, it would be wise to be mindful of performance when making heavy use of this function on long strings in performance-sensitive code.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of code points in this string </dd></dl>

</div>
</div>
<a class="anchor" id="a8763707a5d360d5490e59ac9966e7728"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> UtfString::UnicodeString::substr </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code><a class="el" href="class_utf_string_1_1_unicode_string.html#a1362101b835563b746be6bb2c048c547">npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a substring of this string. </p>
<p>The offset parameter indicates which character in the string will become the first character of the substring and the count parameter indicates how many characters will be copied into the substring. If the value of count would cause characters beyond the end of this string to be copied, only characters from the offset to the end of the string will be copied.</p>
<p>This function assumes that offset &lt; <a class="el" href="class_utf_string_1_1_unicode_string.html#a6712e63301f5b44c7248b2e8bdb21c27" title="Returns the number of code points in this string. ">length()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>The string offset indicating the first character of the substring </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>The number of characters to be copied into the substring</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A substring as describe by the parameters </dd></dl>

</div>
</div>
<a class="anchor" id="ad57ea0924607bbfbf742e21e188b2321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UtfString::UnicodeString::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeString</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this string with those of another string. </p>
<p>This function assumes that <a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371" title="Indicates whether this string is a valid Unicode string. ">is_valid()</a> is true and unicodeString.is_valid() is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeString</td><td>The string whose contents are to be swapped with the contents this string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4794eab4345eb44cedc93c9c09ed0402"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UtfString::UnicodeString::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf8String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this string with those of another string. </p>
<p>This function assumes that <a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371" title="Indicates whether this string is a valid Unicode string. ">is_valid()</a> is true and utf8String.is_valid() is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf8String</td><td>The string whose contents are to be swapped with the contents this string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af12cd3b7af52cba4a94475ac88bcbffb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UtfString::UnicodeString::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String</a> &amp;&#160;</td>
          <td class="paramname"><em>utf16String</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the contents of this string with those of another string. </p>
<p>This function assumes that <a class="el" href="class_utf_string_1_1_unicode_string.html#a609ad252e64f3a3565c2a38109c08371" title="Indicates whether this string is a valid Unicode string. ">is_valid()</a> is true and utf16String.is_valid() is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">utf16String</td><td>The string whose contents are to be swapped with the contents this string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a55b1b7a5aeb775841a2f318503a358a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator converts the contents of a <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> to a stream of bytes. </p>
<p>This function will write to the stream depending on the internal encoding of the <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> object. If the internal encoding is UTF-8, the stream will be written to as a stream of UTF-8 characters, and if the internal incoding is UTF-16, the stream will be written to a stream of UTF-16 characters. If the string does not have an internal encoding(uninitialized), nothing will be written to the stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outputStream</td><td>The output stream to which the contents of the UTF-8 string are to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeString</td><td>The <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> to be written to the output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90a7f4162c19208853198b4f6d5b43c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>outputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator converts a Unicode string to a wide stream of 16-bit values. </p>
<p>No checks for validity are done, so the resulting UTF-16 stream may or may not contain a valid UTF-16 string.</p>
<p>If the <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> contains a UTF-8 string, the function converts it to a UTF-16 string first. What happens when the UTF-8 string is invalid is undefined, so you better make sure your UTF-8 string is valid before doing this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outputStream</td><td>The wide output stream to which the contents of the UTF-16 string are to be written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeString</td><td>The Unicode string to be written to the output stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a88b0374b3119befda9ffefe895e9b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>inputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator reads a stream of bytes into a <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a>. </p>
<p>This function clears the contents of the string before anything is read. This function will read the stream depending on the internal encoding of the <a class="el" href="class_utf_string_1_1_unicode_string.html" title="Contains and manages an encoding-neutral Unicode string. ">UnicodeString</a> object. If the internal encoding is UTF-8, the stream will be read as a stream of UTF-8 characters, and if the internal incoding is UTF-16, the stream will be read as a stream of UTF-16 characters. If the string does not have an internal encoding(uninitialized), we will assume we are reading a stream of UTF-8 characters</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputStream</td><td>The input stream bytes to be read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeString</td><td>The string object in which the stream contents will be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_utf_string_1_1_unicode_string.html#a83b2fecfac699d42b37e849350cda68c" title="Indicates the internal encoding used by this string. ">UnicodeString::internal_encoding()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a14729904560449291367f2dd85fd1be6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wistream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::wistream &amp;&#160;</td>
          <td class="paramname"><em>inputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>unicodeString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operator converts a wide stream of 16-bit values to a UTF-16 string and stores the UTF-16 string inside unicodeString. </p>
<p>This function clears the contents of unicodeString before the stream is converted. In addition this function assumes that the stream being converted is of the same endianness as the machine on which this function was compiled.</p>
<p>This function always assumes that that a wide stream contains a UTF-16 string, and not a UTF-8 string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputStream</td><td>The wide input stream containing 16-bit values to be converted to a UTF-16 string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unicodeString</td><td>The string object into which the converted UTF-16 string will be stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Development/Libraries/UtfString/include/utfstring/<a class="el" href="_unicode_string_8h.html">UnicodeString.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jun 22 2013 21:27:24 for UtfString by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
