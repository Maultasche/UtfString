<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>UtfString: Design and Implementation Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">UtfString
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Design and Implementation Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="namespace_utf_string.html">UtfString</a> is built on top of the Standard Template Library (STL) string classes. This is to give it an efficient, well-established base of code without having to reinvent the wheel. The std::string and std::wstring classes are already capable of handling 8-bit or 16-bit code units, but they have no concept of code points consisting of a variable number of code units; so this library provides the Utf8String and Utf16String, which extend the functionality of the STL string classes. Utf8String and Utf16String abstract the code units, allowing code points to be accessed and manipulated as if they were simple fixed-width characters. This allows the programmer to focus on the characters in the string, and not the individual code units.</p>
<p>The only time individual code units are of interest to the programmer when using the <a class="el" href="namespace_utf_string.html">UtfString</a> library is when strings are being converted to and from a collection of code units. For example, when passing a char[] array or a std::string containing code units to the constructor of Utf8String, the programmer may have to consider the individual code units in that array or string. Once a Utf8String or Utf16String instance has been created, however, code units rarely come into consideration.</p>
<p>The <a class="el" href="struct_utf_string_1_1_utf8_string.html">Utf8String </a> class encapsulates std::string, which is a defined as std::basic_string&lt;char&gt;. The encapsulated std::string class provides the functionality to store and manipulate the 8-bit code units, and Utf8String extends that functionality to allow the programmer to deal with code points instead of code units. The <a class="el" href="struct_utf_string_1_1_utf16_string.html">Utf16String </a> class is very similar to the Utf8String class, encapsulating std::basic_string&lt;UInt16&gt;, where UInt16 is defined as a 16-bit data type. The reason Utf16String does not encapsulate std::wstring is that std::wstring is defined as std::basic_string&lt;wchar_t&gt;. The problem with wchar_t is that it may be a 16-bit data type on some platforms, but a 32-bit data type on other platforms. We want to be sure that the data type we are using to hold a UTF-16 code unit is actually 16-bit, so we define the UInt16 data type in the header files, with the actual C++ data type depending on which platform it is compiled for. If the programmer desires, they can get access to a the encapsulated string of code units by casting a Utf8String to std::string or Utf16String to std::basic_string&lt;UInt16&gt;.</p>
<p>Originally, Utf8String and Utf16String inherited std::string and std::basic_string&lt;UInt16&gt;. That was changed to encapsulation, however, after it was discovered that the STL string classes lack virtual destructors. According to the C++ standard, the behavior when inheriting a class without a virtual destructor is undefined, which may cause apparently random undesirable things to happen. In practice, it is fairly common for programmers to inherit classes without virtual destructors, and most compilers probably are able to deal with it without resulting in any undesired behavior. However, since there are lots of warnings about inheriting STL string classes, and there is a small possibility of undesirable behavior, Utf8String and Utf16String have been redone to use encapsulation instead of inheritance. There is almost no difference from an interface perspective: almost all the changes involved internal code that is invisible to the users of the classes. The only change to the interface was to add an operator that allowed the UTF string class to be cast to its underlying STL string class, so that the user of the class could access the code units. This "change" wasn't even a noticable change, as it preserved the ability to cast to an STL string class that had been present when using inheritance.</p>
<p>The <a class="el" href="namespace_utf_string.html">UtfString</a> library also contains the <a class="el" href="class_utf_string_1_1_unicode_string.html">UnicodeString </a> class. The users of this library may run into situations where it is necessary to pass an encoding-agostic string, and the code will have no idea ahead of time whether the string it will be using is a UTF-8 or UTF-16 string. The UnicodeString class will be very useful in such a situation, as it is an encoding-neutral class. UnicodeString is really a thin wrapper class that contains either a Utf8String or a Utf16String class, depending what is assigned to it. This class is not intended as a general-use string class, but is intended as a class to be used when the programmer has no idea what encoding will be used at runtime. Due to the extra level of complexity in the UnicodeString class (it needs to call methods on the encapsulated encoding-specific object), the Utf8String and Utf16String classes are more efficient. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jun 22 2013 21:27:23 for UtfString by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
